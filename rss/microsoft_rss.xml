<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:wfw="http://wellformedweb.org/CommentAPI/"><channel><title>微软研究院博客 - 微软研究院</title><atom:link href="https://www.microsoft.com/en-us/research/blog/feed/?from=https%3A%2F%2Fresearch.microsoft.com%2Frss%2Fnews.xml&amp;type=rss" rel="self" type="application/rss+xml"></atom:link><link/> https://www.microsoft.com/en-us/research/blog/<description></description><lastbuilddate> 2024 年 3 月 19 日星期二 16:51:47 +0000</lastbuilddate><language> en-US</language><sy:updateperiod>每小时</sy:updateperiod><sy:updatefrequency>1</sy:updatefrequency><generator> https://wordpress.org/?v=6.4.3</generator><item><title>智能监控：迈向云服务AI辅助监控</title><link/>https://www.microsoft.com/en-us/research/blog/intelligent-monitoring-towards-ai-assistance-monitoring-for-cloud-services/<dc:creator><![CDATA[Alyssa Hughes]]></dc:creator><pubDate> Tue, 19 Mar 2024 16:21:49 +0000</pubDate> <category><![CDATA[Research Blog]]></category><guid ispermalink="false"></guid><description><![CDATA[<p>将人工智能集成到云服务监控中可以提高事件检测的准确性，减少不必要的警报，并增强整体系统的可靠性。这有助于组织更好地实现业务目标并提高客户满意度。</p><p>这篇文章<a href="https://www.microsoft.com/en-us/research/blog/intelligent-monitoring-towards-ai-assisted-monitoring-for-cloud-services/">《智能监控：面向云服务的 AI 辅助监控》</a>首先出现在<a href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>; </description><content:encoded><![CDATA[
<figure class="wp-block-image size-full"><img fetchpriority="high" decoding="async" width="1400" height="788" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligent-Monitoring-BlogHeroFeature-1400x788-1.png" alt="蓝色和绿色渐变背景上的三个白色图标" class="wp-image-1013082" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligent-Monitoring-BlogHeroFeature-1400x788-1.png 1400w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligent-Monitoring-BlogHeroFeature-1400x788-1-300x169.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligent-Monitoring-BlogHeroFeature-1400x788-1-1024x576.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligent-Monitoring-BlogHeroFeature-1400x788-1-768x432.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligent-Monitoring-BlogHeroFeature-1400x788-1-1066x600.png 1066w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligent-Monitoring-BlogHeroFeature-1400x788-1-655x368.png 655w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligent-Monitoring-BlogHeroFeature-1400x788-1-240x135.png 240w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligent-Monitoring-BlogHeroFeature-1400x788-1-640x360.png 640w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligent-Monitoring-BlogHeroFeature-1400x788-1-960x540.png 960w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligent-Monitoring-BlogHeroFeature-1400x788-1-1280x720.png 1280w" sizes="(max-width: 1400px) 100vw, 1400px" /></figure><p>在不断发展的软件开发领域，专业人员越来越多地采用称为面向服务架构的现代方法来增强其服务和应用程序的可扩展性和灵活性。开发人员通常利用微服务方法将软件构建为小型、独立运行的服务的集合。这种方法对于开发基于云的软件特别有利，因为它比传统的整体架构具有许多优势，包括单独开发、部署和扩展应用程序的各个组件的能力。然而，这种方法也带来了挑战，尤其是这些服务的离线测试困难，这可能导致只有在软件使用后才发现问题，从而可能导致昂贵的维修费用和用户不满。这强调了仔细软件部署的必要性，确保软件在发布之前尽可能没有错误。</p><p>目前，设置云服务监控的过程在很大程度上依赖于反复试验和服务经理的专业知识，他们必须了解系统的架构、其依赖性以及服务级别协议 (SLA) 中概述的期望。通常，为了应对新出现的问题，在服务启动后会对监控设置进行调整。这种反应性方法可能会导致效率低下，并且经常会错过关键的监控检查，直到出现问题。它还会创建浪费资源的冗余警报。同时，未经优化的监控系统可能会误检测异常行为，从而对用户体验产生负面影响，并可能延长系统升级或迁移所需的时间。为了改进我们监控大型云计算系统的方式，我们需要更好地了解这些系统的工作原理。然后，我们可以确定如何减少漏检数量，同时减少不必要的警报数量。</p><h2 class="wp-block-heading" id="microsoft-cloud-monitor-platforms">微软云监控平台</h2><p>正确配置后，云监控器可以帮助满足监控要求。在<a href="https://www.microsoft.com/en-us/research/group/systems-innovation/overview/">M365 Research</a> ，我们的智能监控项目解决了管理大型服务系列监控器组合的挑战，确保高可靠性和效率。</p><p> <a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://azure.microsoft.com/en-us/products/monitor" target="_blank" rel="noreferrer noopener">Azure Monitor <span class="sr-only">（在新选项卡中打开）</span></a>提供了一个全面的解决方案，用于跨云和本地环境收集、分析和响应监控数据，支持应用程序、虚拟机、容器（包括 Prometheus 指标）、数据库和安全性等一系列资源和社交活动。然而，虽然它在异常检测、根本原因分析和时间序列分析方面表现出色，但在监控设置过程中引入额外的智能可以进一步提高其效率。</p><h2 class="wp-block-heading" id="a-closer-look-at-monitors-and-incident-detection-at-microsoft">深入了解 Microsoft 的监视器和事件检测</h2><p>在我们在<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://2023.esec-fse.org/details/fse-2023-industry/39/-Remote-Detection-Is-Better-Than-Cure-A-Cloud-Incidents-Perspective" target="_blank" rel="noreferrer noopener">ESEC/FSE 2023 <span class="sr-only">（</span></a> <a href="https://www.microsoft.com/en-us/research/publication/detection-is-better-than-cure-a-cloud-incidents-perspective/"><span class="sr-only">在新选项卡中打开）上发表的论文“检测优于治疗：云事件视角（</span>在</a>新选项卡中打开）”中，我们通过研究 Microsoft 一年的生产事件来解决这个问题了解误检测。目标是利用我们的见解来改进数据驱动的监控。</p><p>我们确定了误检测的六个主要原因，从丢失信号和监视器到不正确的监视器覆盖范围和警报逻辑，以及有缺陷的监视器和不充分的文档。图 1 (a) 显示了事件误检测在各种类别中的分布情况。值得注意的是，丢失的监控器和警报占所有误检测的 40% 以上，这表明确定云服务中监控内容的复杂性。第二个最常见的问题是信号不正确或丢失，这表明需要设置用于创建新监视器的信号。此外，大约 10% 的监控器覆盖范围不当，大约 13% 的监控器具有需要重新评估的警报逻辑。图 1 (b) 显示，27.25% 的误检测导致了中断，这凸显了准确定义监控参数的重要性。 </p><figure class="wp-block-image aligncenter size-full"><img decoding="async" width="1600" height="729" src="https://www.microsoft.com/en-us/research/uploads/prodnew/2024/03/Intelligent-Monitoring_Fig1_v2.png" alt="左侧的条形图说明了事件误检测的主要类别。右侧是一个条形图，显示每次漏检导致中断的事件比例。" class="wp-image-1015638" srcset="https://www.microsoft.com/en-us/research/uploads/prodnew/2024/03/Intelligent-Monitoring_Fig1_v2.png 1600w, https://www.microsoft.com/en-us/research/uploads/prodnew/2024/03/Intelligent-Monitoring_Fig1_v2-300x137.png 300w, https://www.microsoft.com/en-us/research/uploads/prodnew/2024/03/Intelligent-Monitoring_Fig1_v2-1024x467.png 1024w, https://www.microsoft.com/en-us/research/uploads/prodnew/2024/03/Intelligent-Monitoring_Fig1_v2-768x350.png 768w, https://www.microsoft.com/en-us/research/uploads/prodnew/2024/03/Intelligent-Monitoring_Fig1_v2-1536x700.png 1536w, https://www.microsoft.com/en-us/research/uploads/prodnew/2024/03/Intelligent-Monitoring_Fig1_v2-240x109.png 240w" sizes="(max-width: 1600px) 100vw, 1600px" /><figcaption class="wp-element-caption">图 1.(a) 误检的主要类别。 (b) 每个误检测类别导致中断的事件比例。</figcaption></figure><h2 class="wp-block-heading" id="data-driven-intelligent-monitoring">数据驱动智能监控</h2><h3 class="wp-block-heading" id="organizing-monitor-data">整理监控数据</h3><p>由于没有构建监视器的标准化方法，因此监视器数据通常缺乏结构。为了解决这个问题，我们定义了一个由类别或类组成的结构，用于监视不同类型的资源，以及用于其相关目标的服务级别目标 (SLO) 类。这些类捕获用户可能想要对资源执行的测量类型。</p><p>在我们将于 ICSE 2024 <a href="https://www.microsoft.com/en-us/research/publication/intelligent-monitoring-framework-for-cloud-services-a-data-driven-approach/">（<span class="sr-only">在新选项卡中打开）上发表的论文“云服务智能监控框架：数据驱动方法（</span>在新</a><a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://conf.researchr.org/details/icse-2024/icse-2024-software-engineering-in-practice/42/Intelligent-Monitoring-Framework-for-Cloud-Services-A-Data-Driven-Approach" target="_blank" rel="noreferrer noopener"><span class="sr-only">选项卡中打开）</span></a> ”中，我们提出了一种用于开发此本体的数据驱动方法。通过利用法学硕士和人在环方法，我们有效地从监控元数据中提取信号。这种方法有助于监测本体的增量开发，并通过人工验证和细化预测结果来确保准确性。</p><h4 class="wp-block-heading" id="breakdown-of-resource-and-slo-classes">资源和 SLO 类别的细分</h4><p>在我们的分析中，我们确定了与数据集中的大多数监视器相对应的 13 个主要资源类和 9 个 SLO 类，如图 2 所示。 </p><figure class="wp-block-image aligncenter size-full"><img decoding="async" width="1600" height="737" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Intelligent-Monitoring_Fig2.png" alt="左侧是一个条形图，显示监视器级别的资源类细分。右侧是一个条形图，显示监视器级别的 SLO 类别的细分。" class="wp-image-1013058" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Intelligent-Monitoring_Fig2.png 1600w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Intelligent-Monitoring_Fig2-300x138.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Intelligent-Monitoring_Fig2-1024x472.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Intelligent-Monitoring_Fig2-768x354.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Intelligent-Monitoring_Fig2-1536x708.png 1536w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Intelligent-Monitoring_Fig2-240x111.png 240w" sizes="(max-width: 1600px) 100vw, 1600px" /><figcaption class="wp-element-caption">图 2.(a) 监视器级别的资源类别细分。 (b) 监控级别的 SLO 类别细分。</figcaption></figure><p>我们分析了每个资源类中 SLO 类的分布，以确定它们之间的关系。我们观察到，资源类别之间的分布各不相同，这表明应将指标类别的特定子集应用于每个资源类别，如图 3 所示。这表明我们可以通过分析其关联的资源类别来预测服务的 SLO 类别。 </p><figure class="wp-block-image aligncenter size-full"><img loading="lazy" decoding="async" width="1200" height="627" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligence-Monitoring.jpg" alt="显示每个资源类中 SLO 类分布的堆叠条形图。" class="wp-image-1013067" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligence-Monitoring.jpg 1200w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligence-Monitoring-300x157.jpg 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligence-Monitoring-1024x535.jpg 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligence-Monitoring-768x401.jpg 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Cloud-Intelligence-Monitoring-240x125.jpg 240w" sizes="(max-width: 1200px) 100vw, 1200px" /><figcaption class="wp-element-caption">图 3：每个资源类中 SLO 类的分布</figcaption></figure><h3 class="wp-block-heading" id="monitor-recommendation-model">监控推荐模型</h3><p>我们开发了一个深度学习框架，可以根据特定服务的属性推荐某些监视器。该模型使用具有结构化本体和服务属性的监视器来创建推荐管道，如图 4 所示。它包含上游和下游依赖项以及服务组件。 </p><figure class="wp-block-image aligncenter size-full"><img loading="lazy" decoding="async" width="3206" height="1500" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Fig6.png" alt="展示推荐管道的图表。" class="wp-image-1013073" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Fig6.png 3206w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Fig6-300x140.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Fig6-1024x479.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Fig6-768x359.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Fig6-1536x719.png 1536w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Fig6-2048x958.png 2048w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Fig6-240x112.png 240w" sizes="(max-width: 3206px) 100vw, 3206px" /><figcaption class="wp-element-caption">图 4：监控推荐管道</figcaption></figure><p>为了识别数据中的模式，该模型使用原型学习网络，该网络学习类或原型的抽象表示。这种方法允许网络比较原型进行分类，从而实现更强的泛化能力。在预测阶段，模型输出它识别为最可能的类别，并使用自定义阈值确保建议具有生产质量。表 1 对此进行了说明。</p><figure class="wp-block-table aligncenter"><table><thead><tr><th>资源类</th><th>临界点</th><th>精确</th><th>记起</th></tr></thead><tbody><tr><td>服务水平</td><td>0.45</td><td> 0.95</td><td> 1.00</td></tr><tr><td>应用程序编程接口</td><td>0.30</td><td> 0.48</td><td> 1.00</td></tr><tr><td>中央处理器</td><td>0.20</td><td> 0.34</td><td> 1.00</td></tr><tr><td>容器</td><td>0.40</td><td> 0.30</td><td> 0.38</td></tr><tr><td>依赖性</td><td>0.20</td><td> 0.28</td><td> 1.00</td></tr><tr><td>计算集群</td><td>0.05</td><td> 0.30</td><td> 1.00</td></tr><tr><td>贮存</td><td>0.35</td><td> 0.22</td><td> 1.00</td></tr><tr><td> RAM内存</td><td>0.30</td><td> 0.20</td><td> 1.00</td></tr><tr><td>证书</td><td>0.50</td><td> 0.14</td><td> 0.80</td></tr><tr><td>高速缓存存储器</td><td>0.41</td><td> 0.13</td><td> 0.88</td></tr><tr><td>其他的</td><td>0.40</td><td> 0.10</td><td> 0.90</td></tr></tbody></table><figcaption class="wp-element-caption">表 1：根据拟议框架的建议评估的定量指标。</figcaption></figure><p>最后，为了了解显示器建议的重要性和实用性以及工程师如何看待它们，我们采访了 11 位在 2023 年 1 月至 6 月期间修改显示器的 Microsoft 工程师。我们介绍了提议的本体，询问它是否有帮助，并征求对新类的建议。该本体的平均评分为 4.27（满分 5 分），表明其有用性。</p><h2 class="wp-block-heading" id="looking-ahead">展望未来</h2><p><a></a>开发监控本体以及为云平台创建性能监视器的推荐框架，标志着解决与监视器管理相关的复杂性的初步步骤。一个名为“监控记分卡”的计划项目旨在通过事件报告、其下游影响、解决时间和覆盖范围来系统地分析监控性能。这种方法将贝叶斯统计与时间序列建模相结合，以估计监测器的有效性，通过对误报和误报进行分类和量化，为监测器组合的性能提供可操作的见解。我们希望这些有效性评估能够加强推荐模型的训练阶段并改进它们提出的推荐。</p><h2 class="wp-block-heading" id="acknowledgments">致谢</h2><p>我们要感谢 Azure 健康平台团队、微软研究院以及数据、知识和智能 (DKI) 团队的同事为这项工作做出的贡献。</p><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span><p>这篇文章<a href="https://www.microsoft.com/en-us/research/blog/intelligent-monitoring-towards-ai-assisted-monitoring-for-cloud-services/">《智能监控：面向云服务的 AI 辅助监控》</a>首先出现在<a href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>;</content:encoded></item><item><title> Garnet 简介 – 一种开源、下一代、更快的缓存存储，用于加速应用程序和服务</title><link/>https://www.microsoft.com/en-us/research/blog/introducing-garnet-an-open-source-next- Generation-faster-cache-store-for-acceleating-applications-and-services/<dc:creator><![CDATA[Alyssa Hughes]]></dc:creator><pubDate> Mon, 18 Mar 2024 21:03:58 +0000</pubDate> <category><![CDATA[Research Blog]]></category><guid ispermalink="false"></guid><description><![CDATA[<p> Garnet 是一种缓存存储系统，可满足日益增长的数据存储需求，以支持交互式 Web 应用程序和服务。 Garnet 与传统缓存存储相比具有多种优势，现在可以开源下载。</p><p>这篇文章<a href="https://www.microsoft.com/en-us/research/blog/introducing-garnet-an-open-source-next-generation-faster-cache-store-for-accelerating-applications-and-services/">介绍 Garnet – 一种用于加速应用程序和服务的开源、下一代、更快的缓存存储</a>首先出现在<a href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>; </description><content:encoded><![CDATA[
<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="1400" height="788" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet-BlogHeroFeature-1400x788-1.jpg" alt="石榴石色钻石"Rich and Extensible API" at the top, "Memory + Tiered Storage" and "Cluster Mode" to the right, "Ultra-Low Latency Pluggable Network Layer" and "Fast Checkpointing & Logging" on the bottom, "Bare Metal Performance" and "Works Everywhere" to the left." class="wp-image-1011708" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet-BlogHeroFeature-1400x788-1.jpg 1400w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet-BlogHeroFeature-1400x788-1-300x169.jpg 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet-BlogHeroFeature-1400x788-1-1024x576.jpg 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet-BlogHeroFeature-1400x788-1-768x432.jpg 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet-BlogHeroFeature-1400x788-1-1066x600.jpg 1066w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet-BlogHeroFeature-1400x788-1-655x368.jpg 655w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet-BlogHeroFeature-1400x788-1-240x135.jpg 240w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet-BlogHeroFeature-1400x788-1-640x360.jpg 640w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet-BlogHeroFeature-1400x788-1-960x540.jpg 960w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet-BlogHeroFeature-1400x788-1-1280x720.jpg 1280w" sizes="(max-width: 1400px) 100vw, 1400px" /></figure><p> Microsoft 的研究人员近十年来一直致力于满足对数据存储机制日益增长的需求，以支持交互式 Web 应用程序和服务的快速发展。我们的新缓存存储系统称为 Garnet，与传统缓存存储相比具有多种优势，已部署在 Microsoft 的多个用例中，例如 Windows 和 Web 体验平台、Azure 资源管理器和 Azure 资源图，以及现在可以在<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://github.com/microsoft/garnet" target="_blank" rel="noreferrer noopener">https://github.com/microsoft/garnet <span class="sr-only">（在新选项卡中打开）</span></a>上进行开源下载。在开源 Garnet 中，我们希望使开发人员社区能够从其性能提升和功能中受益，以我们的工作为基础，并通过添加新的 API 调用和功能来扩展 Garnet 生态系统。我们还希望开源能够鼓励后续学术研究并在这一重要研究领域开启未来的合作机会。</p><h2 class="wp-block-heading" id="the-cache-store-problem">缓存存储问题</h2><p>云和边缘计算的增长带来了数量和范围不断增加的应用程序和服务，它们需要比以往更高的效率、更低的延迟和更低的成本来访问、更新和转换数据。这些应用程序和服务通常需要在存储交互方面投入大量运营支出，使其成为当今最昂贵和最具挑战性的平台领域之一。作为单独可扩展的远程进程部署的缓存存储软件层可以降低这些成本并提高应用程序性能。这推动了缓存存储行业的发展，其中包括许多开源系统，例如 Redis、Memcached、KeyDB 和 Dragonfly。</p><p>与支持简单获取/设置接口的传统远程缓存存储不同，现代缓存提供丰富的 API 和功能集。它们支持原始字符串、Hyperloglog 等分析数据结构以及排序集和哈希等复杂数据类型。它们允许用户检查点和恢复缓存、创建数据分片、维护复制副本以及支持事务和自定义扩展。</p><p>然而，现有系统通过保持系统设计简单来实现这种功能丰富性，但付出了一定的代价，这限制了充分利用最新硬件功能（例如，多核、分层存储、快速网络）的能力。此外，其中许多系统并未明确设计为易于应用程序开发人员扩展或在不同平台和操作系统上良好运行。</p><h2 class="wp-block-heading" id="introducing-garnet">石榴石简介</h2><p>在 Microsoft Research，我们自 2016 年以来一直在研究现代键值数据库架构。我们之前的工作是<a href="https://www.microsoft.com/en-us/research/uploads/prod/2018/03/faster-sigmod18.pdf" target="_blank" rel="noreferrer noopener">FASTER <span class="sr-only">（在新选项卡中打开）</span></a>嵌入式键值库，我们于 2018 年<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://github.com/microsoft/FASTER" target="_blank" rel="noreferrer noopener">开源<span class="sr-only">（在新选项卡中打开）</span></a> ，展示了性能比现有系统好几个数量级，同时专注于简单的单节点进程内键值模型。</p><p>从 2021 年开始，根据 Microsoft 用例的要求，我们开始构建一个新的远程缓存存储，其中包含所有必要的功能，以作为现有缓存存储的可行替代方案。我们的挑战是保持和增强我们在早期工作中取得的性能优势，但在这个更普遍和更现实的网络环境中。</p><p>这项工作的成果是 Garnet——一种新的缓存存储，它具有以下几个独特的优点：</p><ul><li> Garnet 采用流行的 RESP 线路协议作为起点，这使得可以从当今大多数编程语言中可用的未经修改的 Redis 客户端使用 Garnet。</li><li> Garnet 通过许多客户端连接和小批量提供更好的可扩展性和吞吐量，从而节省大型应用程序和服务的成本。</li><li> Garnet 在第 99<sup>个</sup>和 99.9<sup>个</sup>百分位处表现出更好的客户端延迟，这对于现实场景至关重要。</li><li> Garnet 基于最新的 .NET 技术，具有跨平台、可扩展和现代化的特点。它被设计为易于开发和发展，而不会牺牲常见情况下的性能。我们利用 .NET 丰富的库生态系统来扩展 API，并提供开放的优化机会。由于我们对 .NET 的精心使用，Garnet 在 Linux 和 Windows 上都实现了最先进的性能。 </li></ul><figure class="wp-block-image aligncenter size-full"><img loading="lazy" decoding="async" width="362" height="271" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_intro.png" alt="石榴石色钻石"Rich and Extensible API" at the top, "Memory + Tiered Storage" and "Cluster Mode" to the right, "Ultra-Low Latency Pluggable Network Layer" and "Fast Checkpointing & Logging" on the bottom, "Bare Metal Performance" and "Works Everywhere" to the left." class="wp-image-1011471" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_intro.png 362w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_intro-300x225.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_intro-360x271.png 360w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_intro-80x60.png 80w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_intro-240x180.png 240w" sizes="(max-width: 362px) 100vw, 362px" /></figure><p> <strong>API 功能：</strong> Garnet 支持广泛的 API，包括前面描述的原始字符串、分析和对象操作。它还实现了具有分片、复制和动态密钥迁移的集群模式。 Garnet 支持客户端<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://redis.io/docs/interact/transactions/" target="_blank" rel="noreferrer noopener">RESP 事务<span class="sr-only">（在新选项卡中打开）</span></a>形式的事务和我们自己的 C# 服务器端存储过程，并允许用户在原始字符串和新对象类型上定义自定义操作，所有这些都可以方便地使用 C# ，导致开发自定义扩展的门槛降低。</p><p><strong>网络、存储、集群功能：</strong> Garnet 使用快速且可插拔的网络层，支持未来的扩展，例如利用内核旁路堆栈。它支持安全传输层安全 (TLS) 通信以及基本访问控制。 Garnet 的存储层称为 Tsavorite，是从 OSS FASTER 分叉出来的，包括强大的数据库功能，例如线程可扩展性、分层存储支持（内存、SSD 和云存储）、快速非阻塞<a href="https://www.microsoft.com/en-us/research/uploads/prod/2019/01/cpr-sigmod19.pdf" target="_blank" rel="noreferrer noopener">检查点</a>、恢复、持久性操作日志记录、多-密钥事务支持，以及更好的内存管理和重用。最后，Garnet 支持集群操作模式——稍后会详细介绍。</p><h2 class="wp-block-heading" id="performance-preview">性能预览</h2><p>我们展示了将 Garnet 与领先的开源缓存存储进行比较的一些关键结果。更详细的性能比较可以在我们的网站<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://microsoft.github.io/garnet/" target="_blank" rel="noreferrer noopener">https://microsoft.github.io/garnet/ <span class="sr-only">（在新选项卡中打开）</span></a>上找到。</p><p>我们预配两个运行 Linux (Ubuntu 20.04) 的 Azure 标准 F72s v2 虚拟机（每个虚拟机 72 个 vcpu，144 GiB 内存），并启用加速 TCP。一台机器运行不同的缓存存储服务器，另一台机器专门用于发布工作负载。我们使用自己的基准测试工具，称为<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://github.com/microsoft/Garnet/tree/main/benchmark/Resp.benchmark" target="_blank" rel="noreferrer noopener">Resp.benchmark <span class="sr-only">（在新选项卡中打开）</span></a>来生成所有结果。我们将 Garnet 与<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://redis.io/" target="_blank" rel="noreferrer noopener">Redis <span class="sr-only">（在新选项卡中打开）</span></a> (v7.2)、 <a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://docs.keydb.dev/" target="_blank" rel="noreferrer noopener">KeyDB <span class="sr-only">（在新选项卡中打开）</span></a> (v6.3.4) 和<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://www.dragonflydb.io/" target="_blank" rel="noreferrer noopener">Dragonfly <span class="sr-only">（在新选项卡中打开）</span></a> (v6.2.11) 的最新开源版本进行比较。我们在这些实验中使用均匀随机分布的密钥（Garnet 的共享内存设计对于倾斜的工作负载来说更加有利）。在这些实验中，数据被预先加载到每台服务器上，并适合内存中。 </p><h3 class="wp-block-heading" id="experiment-1-throughput-with-varying-number-of-client-sessions">实验 1：不同数量的客户端会话的吞吐量</h3><p>我们从大批量 GET 操作（每批 4096 个请求）和小负载（8 字节键和值）开始，以最大限度地减少网络开销，并在增加客户端会话数量时比较系统。从图 1 中我们看到，Garnet 表现出比 Redis 和 KeyDB 更好的可扩展性，同时实现了比所有三个基线系统更高的吞吐量（y 轴是对数刻度）。请注意，虽然 Dragonfly 显示出与 Garnet 类似的缩放行为，但它是一个纯粹的内存系统。此外，当数据库大小（即预加载的不同键的数量）明显大于处理器缓存所能容纳的大小（2.56 亿个键）时，Garnet 相对于其他系统的吞吐量仍然很强。</p><figure class="wp-block-image aligncenter size-full"> <a href="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig1.png"><img loading="lazy" decoding="async" width="1920" height="622" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig1.png" alt="两个簇状柱形图比较了数据库大小分别为 1024 个键和 2.56 亿个键的各种系统（Garnet、Redis、KeyDB 和 Dragonfly）的吞吐量（对数尺度）。 x 轴表示客户端会话数量从 1 到 128。随着客户端会话数量的增加，Garnet 的吞吐量显着提高。" class="wp-image-1011504" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig1.png 1920w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig1-300x97.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig1-1024x332.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig1-768x249.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig1-1536x498.png 1536w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig1-240x78.png 240w" sizes="(max-width: 1920px) 100vw, 1920px" /></a><figcaption class="wp-element-caption">图 1：数据库大小为 (a) 1024 个键和 (b) 2.56 亿个键时的吞吐量（对数尺度）、不同数量的客户端会话</figcaption></figure><h3 class="wp-block-heading" id="experiment-2-throughput-with-varying-batch-sizes">实验 2：不同批量大小的吞吐量</h3><p>接下来，我们使用 GET 操作和固定数量 (64) 的客户端会话来改变批量大小。我们像以前一样尝试两种不同的数据库大小。图 2 显示，即使没有批处理，Garnet 也能表现更好，而且即使批处理规模非常小，差距也会增大。有效负载大小与以前相同。同样，y 轴是对数刻度。</p><figure class="wp-block-image aligncenter size-full"> <a href="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig2.png"><img loading="lazy" decoding="async" width="2506" height="914" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig2.png" alt="两个簇状柱形图比较了数据库大小分别为 1024 个键和 2.56 亿个键的各种系统（Garnet、Redis、KeyDB 和 Dragonfly）的吞吐量（对数尺度）。 x 轴的批量大小从 1 到 4096 不等。即使是小批量，Garnet 的吞吐量也能显着受益。" class="wp-image-1011516" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig2.png 2506w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig2-300x109.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig2-1024x373.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig2-768x280.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig2-1536x560.png 1536w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig2-2048x747.png 2048w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig2-240x88.png 240w" sizes="(max-width: 2506px) 100vw, 2506px" /></a><figcaption class="wp-element-caption">图 2：数据库大小为 (a) 1024 个键和 (b) 2.56 亿个键时的吞吐量（对数规模）、不同的批量大小</figcaption></figure><h3 class="wp-block-heading" id="experiment-3-latency-with-varying-number-of-client-sessions">实验 3：不同数量的客户端会话的延迟</h3><p>接下来我们测量各种系统的客户端延迟。图 3 显示，随着我们增加客户端会话数量，与其他系统相比，Garnet 在各个百分位的延迟（以微秒为单位）保持更加稳定和更低。在这里，我们混合发出 80% GET 和 20% SET 操作，没有操作批处理。</p><figure class="wp-block-image aligncenter size-full"> <a href="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig3.png"><img loading="lazy" decoding="async" width="3518" height="914" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig3.png" alt="三个簇状柱形图比较了各种系统（Garnet、Redis、KeyDB 和 Dragonfly）的延迟，分别为中值、第 99 个百分位数和第 99.9 个百分位数。 x 轴将客户端会话数量从 1 变化到 128，不进行批处理，操作混合为 80% GET 和 20% SET。 Garnet 的延迟表现稳定，总体上总体较低。" class="wp-image-1011528" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig3.png 3518w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig3-300x78.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig3-1024x266.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig3-768x200.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig3-1536x399.png 1536w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig3-2048x532.png 2048w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig3-240x62.png 240w" sizes="(max-width: 3518px) 100vw, 3518px" /></a><figcaption class="wp-element-caption">图 3：延迟、不同数量的客户端会话（a）中值、（b）第 99<sup>个</sup>百分位和（c）第 99.9<sup>个</sup>百分位</figcaption></figure><h3 class="wp-block-heading" id="experiment-4-latency-with-varying-batch-sizes">实验 4：不同批量大小的延迟</h3><p>Garnet 的延迟针对自适应客户端批处理和查询系统的许多会话进行了优化。我们将批量大小从 1 增加到 64，并在下面绘制了具有 128 个活动客户端连接的不同百分位数的延迟。我们在图 4 中看到，Garnet 的延迟全面较低。和以前一样，我们混合发出 80% 的 GET 和 20% 的 SET 操作。</p><figure class="wp-block-image aligncenter size-full"> <a href="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig4.png"><img loading="lazy" decoding="async" width="3529" height="914" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig4.png" alt="三个簇状柱形图比较了各种系统（Garnet、Redis、KeyDB 和 Dragonfly）的延迟，分别为中值、第 99 个百分位数和第 99.9 个百分位数。 x 轴的批处理大小从 1 到 64 不等，连接了 128 个客户端会话，操作混合为 80% GET 和 20% SET。 Garnet 的延迟表现稳定，总体上总体较低。" class="wp-image-1011531" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig4.png 3529w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig4-300x78.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig4-1024x265.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig4-768x199.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig4-1536x398.png 1536w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig4-2048x530.png 2048w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Garnet_Fig4-240x62.png 240w" sizes="(max-width: 3529px) 100vw, 3529px" /></a><figcaption class="wp-element-caption">图 4：不同批量大小下的延迟（a）中值、（b）第 99<sup>个</sup>百分位和（c）第 99.9 个<sup>百分</sup>位</figcaption></figure><h2 class="wp-block-heading" id="other-experiments">其他实验</h2><p>我们还尝试了其他功能和操作类型，发现 Garnet 具有良好的性能和扩展性。我们的<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://microsoft.github.io/garnet/docs" target="_blank" rel="noreferrer noopener">文档<span class="sr-only">（在新选项卡中打开）</span></a>提供了更多详细信息，包括如何运行这些实验，以便您可以看到自己的用例的好处。</p><h2 class="wp-block-heading" id="garnet-s-design-highlights">石榴石的设计亮点</h2><p>Garnet 的设计重新思考了整个缓存存储堆栈——从网络上接收数据包，到解析和处理数据库操作，再到执行存储交互。我们建立在多年研究的基础上，在过去十年中发表了 10 多篇研究论文。图5展示了Garnet的整体架构。我们在下面重点介绍一些关键想法。</p><p> Garnet 的网络层继承了受我们之前对<a href="https://www.microsoft.com/en-us/research/publication/achieving-high-throughput-and-elasticity-in-a-larger-than-memory-store/">ShadowFax</a>研究启发的共享内存设计。 TLS 处理和存储交互在 IO 完成线程上执行，避免了常见情况下的线程切换开销。这种方法允许 CPU 缓存一致性将数据传输到网络，而不是传统的基于随机播放的设计，后者需要在服务器上移动数据。 </p><figure class="wp-block-image aligncenter size-full is-resized"><img loading="lazy" decoding="async" width="2532" height="2560" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Figure-5-scaled.jpg" alt="Garnet的整体架构。显示通过解析和 API 实现层的多个网络会话。存储API转化为存储层的读、更新插入、删除、读-修改-写操作。存储由主存储和对象存储组成，它们都输入统一的操作日志。日志可以转发到远程副本。" class="wp-image-1011537" style="width:610px;height:auto" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Figure-5-scaled.jpg 2532w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Figure-5-297x300.jpg 297w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Figure-5-1013x1024.jpg 1013w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Figure-5-768x777.jpg 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Figure-5-1519x1536.jpg 1519w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Figure-5-2025x2048.jpg 2025w, https://www.microsoft.com/en-us/research/uploads/prod/2024/03/Figure-5-178x180.jpg 178w" sizes="(max-width: 2532px) 100vw, 2532px" /><figcaption class="wp-element-caption">图5：Garnet整体架构</figcaption></figure><p>Garnet的存储设计由两个Tsavorite键值存储组成，它们的命运由统一的操作日志绑定。第一个存储称为“主存储”，针对原始字符串操作进行了优化，并仔细管理内存以避免垃圾收集。第二个也是可选的“对象存储”针对复杂对象和自定义数据类型进行了优化，包括排序集、集合、哈希、列表和地理等流行类型。对象存储中的数据类型利用 .NET 库生态系统来实现其当前的实现。它们存储在内存中的堆上（这使得更新非常高效）并以序列化形式存储在磁盘上。未来，我们计划研究使用统一的索引和日志来简化维护。</p><p> Garnet 设计的一个显着特点是其窄腰 Tsavorite 存储 API，用于在顶部实现大型、丰富且可扩展的 RESP API 表面。该 API 包含读取、更新插入、删除和原子读取-修改-写入操作，通过 Garnet 的异步回调实现，以便在每个操作期间的各个点插入逻辑。我们的存储 API 模型使我们能够将 Garnet 的解析和查询处理问题与并发、存储分层和检查点等存储细节完全分开。</p><p> Garnet 进一步增加了对基于两阶段锁定的多密钥交易的支持。可以使用 RESP 客户端事务 (MULTI/EXEC) 或使用 C# 中的服务器端事务存储过程。</p><h2 class="wp-block-heading" id="cluster-mode">集群模式</h2><p>除了单节点执行之外，Garnet还支持集群模式，允许用户创建和管理分片和复制部署。 Garnet 还支持高效、动态的密钥迁移方案来重新平衡分片。用户可以使用标准的Redis集群命令来创建和管理Garnet集群，节点执行gossip来共享和演化集群状态。总的来说，Garnet 的簇模式是一个庞大且不断发展的功能，我们将在后续文章中介绍更多细节。</p><h2 class="wp-block-heading" id="looking-ahead">展望未来</h2><p>由于 Garnet 会部署在其他场景中，我们将在以后的文章中继续分享这些详细信息。我们还期待继续为 Garnet 添加新功能和改进，并与开源社区合作。</p><h3 class="wp-block-heading" id="project-contributors">项目贡献者</h3><p><strong>石榴石核心：</strong> <a href="https://www.microsoft.com/en-us/research/people/badrishc/">Badrish Chandramouli</a> 、 <a href="https://www.microsoft.com/en-us/research/people/vazois/">Vasileios Zois</a> 、 <a href="https://www.microsoft.com/en-us/research/people/lumaas/">Lukas Maas</a> 、Ted Hart、Gabriela Martinez Sanchez、 <a href="https://www.microsoft.com/en-us/research/people/yrajas/">Yoganand Rajasekaran</a> 、 <a href="https://www.microsoft.com/en-us/research/people/talzacc/">Tal Zaccai</a> 、 <a href="https://www.microsoft.com/en-us/research/people/darrenge/">Darren Gehring</a> 、 <a href="https://www.microsoft.com/en-us/research/people/irinasp/">Irina Spiridonova</a> 。</p><p><strong>合作者：</strong> Alan Yang、Pradeep Yadav、Alex Dubinkov、Venugopal Latchupatulla、 <a href="https://www.microsoft.com/en-us/research/people/knutmr/">Knut Magne Risvik</a> 、Sarah Williamson、Narayanan Subramanian、Saurabh Singh、Padmanabh Gupta、Sajjad Rahnama、Reuben Bond、 <a href="https://www.microsoft.com/en-us/research/people/raaboulh/">Rafah Hosn</a> 、 <a href="https://www.microsoft.com/en-us/research/people/surajitc/">Surajit Chaudhuri</a> 、 <a href="https://www.microsoft.com/en-us/research/people/johannes/">Johannes Gehrke</a>等。</p><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span><p>这篇文章<a href="https://www.microsoft.com/en-us/research/blog/introducing-garnet-an-open-source-next-generation-faster-cache-store-for-accelerating-applications-and-services/">介绍 Garnet – 一种开源、下一代、更快的缓存存储，用于加速应用程序和服务，</a>首先出现在<a href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>;</content:encoded></item></channel></rss>