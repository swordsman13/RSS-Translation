<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:wfw="http://wellformedweb.org/CommentAPI/"><channel><title>微软研究院博客 - 微软研究院</title><atom:link href="https://www.microsoft.com/en-us/research/blog/feed/?from=https%3A%2F%2Fresearch.microsoft.com%2Frss%2Fnews.xml&amp;type=rss" rel="self" type="application/rss+xml"></atom:link><link/> https://www.microsoft.com/en-us/research/blog/<description></description><lastbuilddate> 2023 年 9 月 12 日，星期二 19:55:05 +0000</lastbuilddate><language> en-US</language><sy:updateperiod>每小时</sy:updateperiod><sy:updatefrequency>1</sy:updatefrequency><generator> https://wordpress.org/?v=6.3.1</generator><item><title>研究重点：2023 年 9 月 11 日当周</title><link/>https://www.microsoft.com/en-us/research/blog/research-focus-week-of-september-11-2023/<dc:creator><![CDATA[Alyssa Hughes]]></dc:creator><pubDate> Wed, 13 Sep 2023 16:00:00 +0000</pubDate><category><![CDATA[Research Blog]]></category><guid ispermalink="false"> https://www.microsoft.com/en-us/research/?p=966795 </guid><description><![CDATA[<p>本期：语义数据的高效多语言分析有助于提高查询性能；对话问答的生成检索改进了基于对话的界面；一种新工具使用机器学习来解决锂离子电池的容量退化问题。</p><p> <a rel="nofollow" href="https://www.microsoft.com/en-us/research/blog/research-focus-week-of-september-11-2023/">《研究焦点：2023 年 9 月 11 日一周》一文</a>首先出现在<a rel="nofollow" href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>; </description><content:encoded><![CDATA[
<figure class="wp-block-image size-full"><img decoding="async" fetchpriority="high" width="1400" height="264" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/RF24-blog-banner-1400x264-1.png" alt="微软研究焦点 24 | 2023 年 9 月 11 日当周" class="wp-image-967083" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/RF24-blog-banner-1400x264-1.png 1400w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/RF24-blog-banner-1400x264-1-300x57.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/RF24-blog-banner-1400x264-1-1024x193.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/RF24-blog-banner-1400x264-1-768x145.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/RF24-blog-banner-1400x264-1-240x45.png 240w" sizes="(max-width: 1400px) 100vw, 1400px" /></figure><figure class="wp-block-pullquote"><blockquote><p><em class="">欢迎来到研究焦点，这是一系列博客文章，重点介绍 Microsoft 研究社区的著名出版物、活动、代码/数据集、新员工和其他里程碑。</em> </p></blockquote></figure><aside id=accordion-9f5963fc-4b6c-40fe-9c91-20761308ef13 class="msr-table-of-contents-block accordion mb-5 pb-0" data-bi-aN="table-of-contents"> <button class="btn btn-collapse bg-gray-100 mb-0 display-flex justify-content-between" type="button" data-mount="collapse" data-target="#accordion-collapse-9f5963fc-4b6c-40fe-9c91-20761308ef13" aria-expanded="true" aria-controls="accordion-collapse-9f5963fc-4b6c-40fe-9c91-20761308ef13"><span class="msr-table-of-contents-block__label subtitle">在本文中</span><span class="msr-table-of-contents-block__current mr-4 text-gray-600 font-weight-normal" aria-hidden="true"></span></button> <div id="accordion-collapse-9f5963fc-4b6c-40fe-9c91-20761308ef13" class="msr-table-of-contents-block__collapse-wrapper collapse show" data-parent="#accordion-9f5963fc-4b6c-40fe-9c91-20761308ef13"><div class="accordion-body bg-gray-100 border-top pt-4"><ol class="msr-table-of-contents-block__list"><li class="msr-table-of-contents-block__list-item"> <a href="#polysem-efficient-polyglot-analytics-on-semantic-data" class="msr-table-of-contents-block__list-item-link">PolySem：语义数据的高效多语言分析</a></li><li class="msr-table-of-contents-block__list-item"><a href="#generative-retrieval-for-conversational-question-answering" class="msr-table-of-contents-block__list-item-link">对话问答的生成检索</a></li><li class="msr-table-of-contents-block__list-item"><a href="#batteryml-an-open-source-tool-for-machine-learning-on-battery-degradation" class="msr-table-of-contents-block__list-item-link">BatteryML：用于电池退化机器学习的开源工具</a></li></ul></div></div><span class="msr-table-of-contents-block__progress-bar"></span></aside><h3 class="wp-block-heading h6 has-blue-color has-text-color" id="new-research">新研究</h3><h2 class="wp-block-heading" id="polysem-efficient-polyglot-analytics-on-semantic-data">PolySem：语义数据的高效多语言分析</h2><p>数据科学家和数据工程师花费大量时间尝试理解、清理和转换他们的数据，然后才能开始执行有意义的分析。大多数数据库供应商提供商业智能 (BI) 工具作为高效且用户友好的平台，供客户执行数据清理、准备和链接任务，以获得可操作的语义数据。然而，客户对通过各种方式查询语义数据越来越感兴趣，包括 SQL、命令式编程语言（例如 Python）和自然语言查询。如今，客户只能使用这些工具提供的可视化界面或特定工具专用的语言。</p><p>在一篇新论文： <a href="https://www.microsoft.com/en-us/research/publication/polysem-efficient-polyglot-analytics-on-semantic-data/">PolySem：语义数据上的高效多语言分析中，</a>微软的研究人员提出了一些技术，可以在语义数据集上执行以不同模式表达的用户查询，而无需将数据导出 BI 系统。他们的技术包括将用户查询自动翻译成与语言无关的数据处理操作表示，然后翻译成适合在 BI 引擎上执行的特定查询语言。 BI 和决策支持基准的评估结果表明，与其他流行的数据处理引擎相比，查询性能显着提高。 </p><div class="wp-block-buttons is-content-justification-center"><div class="wp-block-button is-style-outline"> <a data-bi-type="button" class="wp-block-button__link wp-element-button" href="https://www.microsoft.com/en-us/research/publication/polysem-efficient-polyglot-analytics-on-semantic-data/">阅读论文</a></div></div><div style="height:20px" aria-hidden="true" class="wp-block-spacer"></div><div class="border-bottom border-top border-gray-300 mt-5 mt-md-4 mb-4 mb-md-5 msr-promo text-center text-md-left alignwide" data-bi-aN="promo" data-bi-id="956142"><p class="msr-promo__label text-gray-800 text-center text-uppercase"><span class="px-4 bg-white display-inline-block font-weight-semibold small">微软研究院播客</span></p><div class="row pt-3 pb-4 align-items-center"><div class="msr-promo__media col-12 col-md-5"> <a class="bg-gray-300" href="https://www.microsoft.com/en-us/research/podcast/collaborators-holoportation-communication-technology-with-spencer-fowers-and-kwame-darko/" aria-label="Collaborators: Holoportation&#x2122; communication technology with Spencer Fowers and Kwame Darko" data-bi-cN="Collaborators: Holoportation&#x2122; communication technology with Spencer Fowers and Kwame Darko" target="_blank"><img decoding="async" class="w-100 display-block" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/06/collaborators_3DTelemed_1400x788.jpg" /></a></div><div class="msr-promo__content p-3 px-5 col-12 col-md"><h2 class="h4">合作者：全息传输<img src="https://s.w.org/images/core/emoji/14.0.0/72x72/2122.png" alt="™" class="wp-smiley" style="height: 1em; max-height: 1em;" /> Spencer Fowers 和 Kwame Darko 的通信技术</h2><p class="large">Spencer Fowers 和 Kwame Darko 详细介绍了 Holoportation 背后的技术以及围绕该技术构建的电信设备如何将患者和医生聚集在一起（当患者和医生待在同一个房间并不容易的情况下），并讨论了这项工作的潜在影响。 </p><div class="wp-block-buttons justify-content-center justify-content-md-start"><div class="wp-block-button"> <a href="https://www.microsoft.com/en-us/research/podcast/collaborators-holoportation-communication-technology-with-spencer-fowers-and-kwame-darko/" class="btn btn-brand glyph-append glyph-append-chevron-right" aria-label="Listen now" data-bi-cN="Collaborators: Holoportation&#x2122; communication technology with Spencer Fowers and Kwame Darko" target="_blank">现在听</a></div></div></div><!--/.msr-promo__content--></div><!--/.msr-promo__inner-wrap--><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span></div><!--/.msr-promo--><h3 class="wp-block-heading h6 has-blue-color has-text-color" id="new-resource">新资源</h3><h2 class="wp-block-heading" id="generative-retrieval-for-conversational-question-answering"> 对话问答的生成检索</h2><p>包括语音助手和聊天机器人在内的对话代理的发展导致信息查找活动转向基于对话的界面。这刺激了对话式问答（QA）系统的发展。有效的段落检索（从扫描文档中排除不相关的数据）至关重要，但由于问题的模糊性，对于此类系统来说具有挑战性。当前的方法依赖于双编码器架构在对话中嵌入情境化的问题向量。然而，这种架构在嵌入瓶颈和点积运算方面受到限制。</p><p>为了缓解这些限制，微软的研究人员提出了<a href="https://www.microsoft.com/en-us/research/publication/generative-retrieval-for-conversational-question-answering/">会话 QA 的生成检索</a>（GCoQA）。 GCoQA 为段落分配独特的标识符，并通过编码器-解码器架构逐个生成标识符来检索段落。通过这种生成方式，GCoQA 消除了对向量式索引的需求，并且可以在每个解码步骤中处理对话上下文的关键标记。在包含约 2000 万段文章的三个公共数据集上进行的实验表明，GCoQA 在段落检索方面实现了 +13.6% 的相对改进，在文档检索方面实现了 +42.9% 的相对改进。 GCoQA 还可以减少内存使用并提高推理速度。 </p><div class="wp-block-buttons is-content-justification-center"><div class="wp-block-button is-style-outline"> <a data-bi-type="button" class="wp-block-button__link wp-element-button" href="https://www.microsoft.com/en-us/research/publication/generative-retrieval-for-conversational-question-answering/">阅读论文</a></div><div class="wp-block-button is-style-fill-github"><a data-bi-type="button" class="wp-block-button__link wp-element-button" href="https://github.com/liyongqi67/GCoQA" target="_blank" rel="noreferrer noopener">查看代码和数据</a></div></div><hr class="wp-block-separator has-alpha-channel-opacity is-style-dots"/><h3 class="wp-block-heading h6 has-blue-color has-text-color" id="new-resource-1">新资源</h3><h2 class="wp-block-heading" id="batteryml-an-open-source-tool-for-machine-learning-on-battery-degradation"> BatteryML：用于电池退化机器学习的开源工具</h2><p>近年来，锂离子电池因其能量密度高、循环寿命长和相对较低的自放电率而成为储能解决方案的基石。它们已在各个行业得到广泛应用，包括电动汽车、消费电子产品和可再生能源系统。尽管具有这些优势，锂离子电池仍面临着容量衰减和性能优化方面的挑战，这已成为电池研究的关键领域。</p><p>容量衰减是一个复杂的过程，受温度、充放电速率和充电状态等多种因素的影响。了解并减轻这些因素对于提高锂离子电池的性能和寿命至关重要。这导致了先进电池管理系统的开发以及机器学习技术的应用，以提高预测精度并优化电池性能。</p><p>为了应对这些挑战，微软的研究人员发布了<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://github.com/microsoft/BatteryML" target="_blank" rel="noreferrer noopener">BatteryML <span class="sr-only">（在新选项卡中打开）</span></a> ，这是一款综合开源工具，专为对电池性能预测和分析感兴趣的机器学习研究人员、电池科学家和材料研究人员而设计。 BatteryML 旨在通过利用机器学习方法改善电池性能的各个方面（例如容量衰减建模、健康状态预测和充电状态估计）来解决容量退化的挑战。 </p><div class="wp-block-buttons is-content-justification-center"><div class="wp-block-button is-style-fill-github"> <a data-bi-type="button" class="wp-block-button__link wp-element-button" href="https://github.com/microsoft/BatteryML" target="_blank" rel="noreferrer noopener">下载代码</a></div></div><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span><p><a rel="nofollow" href="https://www.microsoft.com/en-us/research/blog/research-focus-week-of-september-11-2023/">《研究焦点：2023 年 9 月 11 日一周》一文</a>首先出现在<a rel="nofollow" href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>;</content:encoded></item><item><title> FP2：完全就地函数式编程为纯函数式程序提供内存重用</title><link/>https://www.microsoft.com/en-us/research/blog/fp2-complete-in-place-function-programming-provides-memory-reuse-for-pure-function-programs/<dc:creator><![CDATA[Brenda Potts]]></dc:creator><pubDate> Tue, 12 Sep 2023 16:55:00 +0000</pubDate><category><![CDATA[Research Blog]]></category><guid ispermalink="false"> https://www.microsoft.com/en-us/research/?p=964929 </guid><description><![CDATA[<p>这篇研究论文在第 28 届 ACM SIGPLAN 国际函数式编程会议（在新选项卡中打开）(ICFP) 上发表，该会议是讨论函数式编程的设计、实现、原理和使用的首要论坛。函数式编程语言具有许多优点，例如确保内存安全（在新选项卡中打开）和消除任意副作用。 […]</p><p> <a rel="nofollow" href="https://www.microsoft.com/en-us/research/blog/fp2-fully-in-place-functional-programming-provides-memory-reuse-for-pure-functional-programs/">FP2：完全就地函数式编程为纯函数式程序提供内存重用后的文章</a>首先出现在<a rel="nofollow" href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>; </description><content:encoded><![CDATA[
<p class="has-text-align-center h6">这篇研究论文在<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://icfp23.sigplan.org/" target="_blank" rel="noreferrer noopener"><em>第 28<sup>届</sup>ACM SIGPLAN 国际函数式编程会议</em><span class="sr-only">（在新选项卡中打开）</span></a> (ICFP)<em>上发表</em><em>，该会议是讨论函数式编程的设计、实现、原理和使用的首要论坛。</em> </p><figure class="wp-block-image aligncenter size-full"><img decoding="async" width="1400" height="788" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1.jpg" alt="FP2：完全就地函数式编程； ICFP 2023" class="wp-image-964953" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1.jpg 1400w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-300x169.jpg 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-1024x576.jpg 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-768x432.jpg 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-1066x600.jpg 1066w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-655x368.jpg 655w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-343x193.jpg 343w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-240x135.jpg 240w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-640x360.jpg 640w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-960x540.jpg 960w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-1280x720.jpg 1280w" sizes="(max-width: 1400px) 100vw, 1400px" /></figure><p>函数式编程语言具有许多优点，例如<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf">确保内存安全<span class="sr-only">（在新选项卡中打开）</span></a>和消除任意副作用。这使得系统分析和组合程序构建成为可能，从而促进可扩展和复杂软件系统的开发。然而，函数式编程的一个缺点是它倾向于随意分配新内存。我们认为这一特性阻碍了性能关键领域的广泛采用。我们如何克服这一限制并利用函数式编程的优势，同时保持高效的内存使用？</p><p>为了说明这个问题，让我们检查一下众所周知的函数程序，该程序使用累积参数在线性时间内反转列表： </p><figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_reverse-list-code-block-Koka.png" alt="FP2：完全就地函数式编程 - Koka 中的反向列表代码" class="wp-image-967419" style="width:450px" width="450" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_reverse-list-code-block-Koka.png 751w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_reverse-list-code-block-Koka-300x102.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_reverse-list-code-block-Koka-240x81.png 240w" sizes="(max-width: 751px) 100vw, 751px" /></figure><p>反转函数是用<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://koka-lang.github.io/" target="_blank" rel="noreferrer noopener">Koka <span class="sr-only">（在新选项卡中打开）</span></a>编写的，Koka 是 Microsoft 开发的一种函数式语言，用于实现本博客文章中描述的技术。这里，列表要么是空的（如<code><font color="#800000">Nil</font></code> ），要么是非空的<code><font color="#800000">Cons</font> (head,tail)</code>节点，并且包含第一个元素作为头，列表的其余部分作为<code>tail</code> 。</p><p>在大多数函数式语言中，以这种方式反转列表会在堆中分配一个新的结果列表，其中从 1 到 10 的整数列表被反转，如图 1 所示。 </p><figure class="wp-block-image aligncenter size-large is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig2-1024x950.png" alt="FP2：完全就地函数式编程；图 1 - 该图显示了两个单链表。第一个单链表包含数字 6 到 10，并由"xs." The second single-linked list contains the numbers 5 to 1 and is pointed to by "acc."" class="wp-image-964947" style="width:400px" width="400" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig2-1024x950.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig2-300x278.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig2-768x712.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig2-194x180.png 194w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig2.png 1065w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption class="wp-element-caption">图 1：列表 [1..5] 已经反转为 acc，但我们仍然必须反转列表 [6..10]。</figcaption></figure><p>由于列表<code>xs</code>非空，我们将其第一个元素添加到累积的<code>acc</code>参数中，然后再递归列表<code>xx</code>的其余部分。如图 2 所示，此步骤分配一个新的<code><font color="#800000">Cons</font></code>单元，但也会留下<code>xs</code>的<code><font color="#800000">Cons</font></code>单元进行垃圾回收。这是相当浪费的。 </p><figure class="wp-block-image aligncenter size-large is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig3-1024x978.png" alt="FP2：完全就地函数式编程；图 3 - 该图描绘了两个单链表。第一个单链表包含数字 7 到 10，并由"xs." Above the list, there is the list element containing the number 6, which is now up for deletion and is red. The second single-linked list contains the numbers 6 to 1 and is pointed to by "acc." The list element containing 6 is newly allocated and is green." class="wp-image-964950" style="width:400px" width="400" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig3-1024x978.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig3-300x287.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig3-768x734.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig3-188x180.png 188w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig3.png 1048w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption class="wp-element-caption">图 2：一级递归后的列表。左侧顶部的<code><font color="#800000">Cons</font></code>单元已成为垃圾，而右侧顶部的<code><font color="#800000">Cons</font></code>单元是新分配的。 </figcaption></figure><h2 class="wp-block-heading" id="fully-in-place-functional-programming-avoids-allocation">完全就地函数式编程避免了分配</h2><p>最近的发展使得避免此类分配成为可能。特别是，通过使用名为<a href="https://www.microsoft.com/en-us/research/publication/perceus-garbage-free-reference-counting-with-reuse-2/">Perceus</a>的编译器引导的引用计数算法，只要对象在运行时被唯一引用，我们就可以就地重用对象。通过这种重用，reverse 函数可以<em>就地</em>反转唯一的输入列表 xs，而无需分配任何新的<code><font color="#800000">Cons</font></code>节点，本质上是就地切换 xs 的尾指针。然而，这种重用形式的动态性质使得很难在运行时预测其应用程序。</p><p>在我们在<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://icfp23.sigplan.org/" target="_blank" rel="noreferrer noopener">ICFP 2023 <span class="sr-only">（</span></a> <a href="https://www.microsoft.com/en-us/research/publication/fp2-fully-in-place-functional-programming-2/"><span class="sr-only">在新选项卡中打开）</span>上展示的论文“FP <sup>2</sup> ：完全就地函数式编程（在</a>新选项卡中打开）”中，我们描述了新的<code><font color="#0000FF">fip</font></code>关键字。它静态地检查像累加反向函数这样的程序是否可以<em>就地</em>执行，也就是说，只要参数是唯一的，就可以使用常量堆栈空间，而不需要任何堆分配。 </p><div style="height:30px" aria-hidden="true" class="wp-block-spacer"></div><div class="border-bottom border-top border-gray-300 mt-5 mt-md-4 mb-4 mb-md-5 msr-promo text-center text-md-left alignwide" data-bi-aN="promo" data-bi-id="931959"><p class="msr-promo__label text-gray-800 text-center text-uppercase"><span class="px-4 bg-white display-inline-block font-weight-semibold small">焦点：微软研究院播客</span></p><div class="row pt-3 pb-4 align-items-center"><div class="msr-promo__media col-12 col-md-5"> <a class="bg-gray-300" href="https://www.microsoft.com/en-us/research/podcast/ai-frontiers-the-physics-of-ai-with-sebastien-bubeck/" aria-label="AI Frontiers: The Physics of AI with Sébastien Bubeck" data-bi-cN="AI Frontiers: The Physics of AI with Sébastien Bubeck" target="_blank"><img decoding="async" class="w-100 display-block" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/03/Podcast_Seb-Bubeck_2023Mar_1400x788-641b52c5cf826.png" alt="塞巴斯蒂安·布贝克 (Sebastian Bubeck) 在一张黑白照片中对着镜头微笑，左侧附有微软研究院播客徽标" /></a></div><div class="msr-promo__content p-3 px-5 col-12 col-md"><h2 class="h4">人工智能前沿：Sébastien Bubeck 的人工智能物理学</h2><p class="large">什么是智力？它是如何出现的以及我们如何衡量它？ Ashley Llorens 和机器学习理论家 Sébastian Bubeck 讨论了大规模 AI 的加速进展以及 GPT-4 的早期实验。 <br><a href="https://l.facebook.com/l.php?u=https%3A%2F%2Fmsft.it%2F61835CFKb%3Ffbclid%3DIwAR0sDyENIP-wLZvngSQmw21jreqUIHBbyv2KolZK6H4BWAtwFXsKgafg4xM&h=AT0D-GvhrGXafUSLWmOhIiLMzRcG1ATyEja5CYwPUfDZjUkzJ1I6fxNS8FwoV4imqylt08Oo8VUfdQGTptG3GJTKghii5-Edhjokhyi1Qqf4OxTHBeZ7QHYWLXLpkqnauJYK&__tn__=H-R&c[0]=AT3QF5SN7zvKGA4sdQwPrbtJsfteJuGPZqMh3uC5QsK31BqLN4cz-rtY5Zv_MkR6excR2jLuNWR4qLSSTLSKAJx2vMFxG2oQySRIlSdeR0EBAJ9cx9hLPmj2bu8BeZaNh_dFdUpiBud4lYPPpw7ihcDYAHmic4HS4l7w_Is4L3c5-PTdJC5jLm1nVgySB4mGwIhSY45yB0yJKAE" target="_blank" rel="noreferrer noopener"></a></p><div class="wp-block-buttons justify-content-center justify-content-md-start"><div class="wp-block-button"> <a href="https://www.microsoft.com/en-us/research/podcast/ai-frontiers-the-physics-of-ai-with-sebastien-bubeck/" class="btn btn-brand glyph-append glyph-append-chevron-right" aria-label="Listen now" data-bi-cN="AI Frontiers: The Physics of AI with Sébastien Bubeck" target="_blank">现在听</a></div></div></div><!--/.msr-promo__content--></div><!--/.msr-promo__inner-wrap--><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span></div><!--/.msr-promo--><h2 class="wp-block-heading" id="tree-traversals-and-zippers">树木遍历和拉链</h2><p>事实上，许多熟悉的函数和算法都满足我们完全就地的标准。例如，考虑一棵所有值都位于叶子的二叉树： </p><figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_binary-tree-code-block-Koka.png" alt="FP2：完全就地函数式编程 - Koka 中的二叉树代码" class="wp-image-967398" style="width:300px" width="300" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_binary-tree-code-block-Koka.png 501w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_binary-tree-code-block-Koka-300x67.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_binary-tree-code-block-Koka-240x54.png 240w" sizes="(max-width: 501px) 100vw, 501px" /></figure><p>现在，假设我们想要浏览这棵树，上下移动以搜索特定元素。您可以添加父指针，但在函数式语言中，有一种最初由 Gérard Huet 提出的替代解决方案，称为<em><a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/zipper/0C058890B8A9B588F26E6D68CF0CE204" target="_blank" rel="noreferrer noopener">拉链<span class="sr-only">（在新选项卡中打开）</span></a></em> ： </p><figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_Zipper-code-block-Koka.png" alt="FP2：完全就地函数式编程 - Koka 中的 Zipper 代码" class="wp-image-967401" style="width:300px" width="300" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_Zipper-code-block-Koka.png 511w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_Zipper-code-block-Koka-300x89.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_Zipper-code-block-Koka-240x71.png 240w" sizes="(max-width: 511px) 100vw, 511px" /></figure><div class="annotations " data-bi-aN="margin-callout"><ul class="annotations__list card depth-16 bg-body p-4 annotations__list--right"><li class="annotations__list-item"> <span class="annotations__type d-block text-uppercase font-weight-semibold text-neutral-300 small">下载</span><a href="https://github.com/koka-lang/koka" target="_self" class="annotations__link font-weight-semibold text-decoration-none" data-bi-type="annotated-link" aria-label="Koka" data-bi-aN="margin-callout" data-bi-cN="Koka">Koka<span class="glyph-append glyph-append-share glyph-append-xsmall"></span></a></li></ul></div><p> zipper 沿着从当前节点到根节点的路径存储子树。我们可以定义由这种类型的拉链和当前树组成的对的操作，从而实现在树中的无缝移动。例如，以下函数使用拉链将焦点移动到左子树： </p><figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_left-subtree-code-block-Koka.png" alt="FP2：完全就地函数式编程 - 重点关注 Koka 中的左子树代码" class="wp-image-967395" style="width:480px" width="480" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_left-subtree-code-block-Koka.png 843w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_left-subtree-code-block-Koka-300x53.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_left-subtree-code-block-Koka-768x137.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_left-subtree-code-block-Koka-240x43.png 240w" sizes="(max-width: 843px) 100vw, 843px" /></figure><p>在这里，我们移动到当前节点的左子树（如果存在）并相应地扩展 zipper 数据类型。 Huet 在 1997 年就已经观察到这种拉链操作可以就地实施：</p><figure class="wp-block-pullquote"><blockquote><p><em>二叉树上的高效破坏性算法可以使用这些完全适用的原语进行编程，这些原语都使用恒定时间，因为它们都减少到本地指针操作</em>。</p></blockquote></figure><p>在 Koka 中，我们现在可以使 Huet 的直觉更加精确，其中<code><font color="#0000FF">fip</font></code>关键字保证<code>left</code>就位。仔细观察，这可能会令人惊讶。虽然列表反转示例重用了<code><font color="#800000">Cons</font></code>节点，但这里似乎我们可能需要垃圾收集<code><font color="#800000">Bin</font></code>构造函数并分配新的<code><font color="#800000">BinL</font></code>构造函数。尽管如此，由于两个构造函数都有两个字段，因此仍然可以重用之前的<code><font color="#800000">Bin</font></code>内存位置（仅更新构造函数标记）。我们的<a href="https://www.microsoft.com/en-us/research/publication/fp2-fully-in-place-functional-programming-2/" target="_blank" rel="noreferrer noopener">论文</a>提供了实现这一点的分析细节，植根于“重复使用积分”的概念。</p><p>现在，假设我们要更新存储在树中的所有值。使用拉链，我们可以完全就位做到这一点。遍历时，zipper 按顺序存储输入树片段，使用<code><font color="#800000">BinL</font></code>表示未访问的子树，使用<code><font color="#800000">BinR</font></code>表示已访问的子树。重用拉链节点允许有序树映射，而无需使用堆或堆栈。树映射函数首先下降到最左边的叶子，在<code><font color="#800000">BinL</font></code>中累积未访问的子树。一旦到达最左边的叶子，我们就应用参数函数 f 并向上返回，递归处理任何未访问的子树，如图 3 所示。 </p><figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_unvisited-subtrees-code-block-Koka.png" alt="FP2：完全就地函数式编程 - Koka 中未访问的子树代码" class="wp-image-967392" style="width:540px" width="540" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_unvisited-subtrees-code-block-Koka.png 880w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_unvisited-subtrees-code-block-Koka-300x207.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_unvisited-subtrees-code-block-Koka-768x530.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_unvisited-subtrees-code-block-Koka-240x166.png 240w" sizes="(max-width: 880px) 100vw, 880px" /></figure><p>相互尾递归应用程序和向下功能已完全到位。每个<code><font color="#800000">Bin</font></code>与<code><font color="#800000">BinL</font></code>配对，每个<code><font color="#800000">BinL</font></code>与<code><font color="#800000">BinR</font></code> ，最终导致<code><font color="#800000">BinR</font></code>与<code><font color="#800000">Bin</font></code>配对。 <code>tmap</code>的定义可能看起来有些复杂，但它比使用直接指针反转的迭代命令式对应物要简单得多。 </p><figure class="wp-block-image aligncenter size-large is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1-1024x572.png" alt="FP2：完全就地函数式编程；图 3 - 二叉搜索树的图示，其中搜索路径已被指针反转。总共有五个节点：三个叶节点和两个内部节点。第一个叶节点是根的左子节点并且已经被访问过。根节点标记为"BinR" since our method descended into its right subtree. The root does not point to a right child, but instead its former right child points up to the root. This former child is marked "BinL" since our search descended into its left child, and its right child is an unvisited leaf. At this state of the program, our accumulator "acc" is the former right child of the root, and our current element "xs" is the former left child of the former right child of the root." class="wp-image-964944" style="width:400px" width="400" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1-1024x572.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1-300x168.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1-768x429.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1-343x193.png 343w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1-240x134.png 240w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1.png 1502w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption class="wp-element-caption">图 3：访问​​给定树上包含 f(2) 的叶子后的程序。拉链上的指针是相反的。</figcaption></figure><h2 class="wp-block-heading" id="perspectives-and-further-reading">观点和进一步阅读</h2><p>Koka 的新<code><font color="#0000FF">fip</font></code>关键字确保某些函数不分配而仅使用常量堆栈空间，提供类似于静态线性类型或 Rust 借用检查器的高效且安全的代码执行。这引入了一种新的范例，用于编写纯函数式但仍可以就地执行的程序。我们认为这项新技术是使用高级函数式编程开发强大的软件以提供具有竞争力和可预测性能的道路上的一个重要里程碑。</p><p>要了解完全就地函数式编程和 Koka 语言，请从<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://koka-lang.github.io/koka/doc/index.html" target="_blank" rel="noreferrer noopener">Koka 主页<span class="sr-only">（在新选项卡中打开）</span></a>开始。 Koka 实现了各种创新的语言功能，包括代数效果处理程序和一流的构造函数上下文。我们鼓励读者继续探索和尝试完全就地编程。例如，尝试在 Koka 中实现<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://en.wikipedia.org/wiki/Skew_heap" target="_blank" rel="noreferrer noopener">倾斜二进制堆<span class="sr-only">（在新选项卡中打开）</span></a> 。您能演示完全就地堆联合吗？</p><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span><p><a rel="nofollow" href="https://www.microsoft.com/en-us/research/blog/fp2-fully-in-place-functional-programming-provides-memory-reuse-for-pure-functional-programs/">FP2：完全就地函数式编程为纯函数式程序提供内存重用后的文章</a>首先出现在<a rel="nofollow" href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>;</content:encoded></item></channel></rss>