<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:wfw="http://wellformedweb.org/CommentAPI/"><channel><title>微软研究院博客 - 微软研究院</title><atom:link href="https://www.microsoft.com/en-us/research/blog/feed/?from=https%3A%2F%2Fresearch.microsoft.com%2Frss%2Fnews.xml&amp;type=rss" rel="self" type="application/rss+xml"></atom:link><link/> https://www.microsoft.com/en-us/research/blog/<description></description><lastbuilddate> 2023 年 9 月 12 日，星期二 16:58:07 +0000</lastbuilddate><language> en-US</language><sy:updateperiod>每小时</sy:updateperiod><sy:updatefrequency>1</sy:updatefrequency><generator> https://wordpress.org/?v=6.3.1</generator><item><title> FP2：完全就地函数式编程为纯函数式程序提供内存重用</title><link/>https://www.microsoft.com/en-us/research/blog/fp2-complete-in-place-function-programming-provides-memory-reuse-for-pure-function-programs/<dc:creator><![CDATA[Brenda Potts]]></dc:creator><pubDate> Tue, 12 Sep 2023 16:55:00 +0000</pubDate><category><![CDATA[Research Blog]]></category><guid ispermalink="false"> https://www.microsoft.com/en-us/research/?p=964929 </guid><description><![CDATA[<p>这篇研究论文在第 28 届 ACM SIGPLAN 国际函数式编程会议（在新选项卡中打开）(ICFP) 上发表，该会议是讨论函数式编程的设计、实现、原理和使用的首要论坛。函数式编程语言具有许多优点，例如确保内存安全（在新选项卡中打开）和消除任意副作用。 […]</p><p> <a rel="nofollow" href="https://www.microsoft.com/en-us/research/blog/fp2-fully-in-place-functional-programming-provides-memory-reuse-for-pure-functional-programs/">FP2：完全就地函数式编程为纯函数式程序提供内存重用后的文章</a>首先出现在<a rel="nofollow" href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>; </description><content:encoded><![CDATA[
<p class="has-text-align-center h6">这篇研究论文在<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://icfp23.sigplan.org/" target="_blank" rel="noreferrer noopener"><em>第 28<sup>届</sup>ACM SIGPLAN 国际函数式编程会议</em><span class="sr-only">（在新选项卡中打开）</span></a> (ICFP)<em>上发表</em><em>，该会议是讨论函数式编程的设计、实现、原理和使用的首要论坛。</em> </p><figure class="wp-block-image aligncenter size-full"><img decoding="async" fetchpriority="high" width="1400" height="788" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1.jpg" alt="FP2：完全就地函数式编程； ICFP 2023" class="wp-image-964953" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1.jpg 1400w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-300x169.jpg 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-1024x576.jpg 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-768x432.jpg 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-1066x600.jpg 1066w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-655x368.jpg 655w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-343x193.jpg 343w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-240x135.jpg 240w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-640x360.jpg 640w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-960x540.jpg 960w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/ICFP23-BlogHeroFeature-1400x788-1-1280x720.jpg 1280w" sizes="(max-width: 1400px) 100vw, 1400px" /></figure><p>函数式编程语言具有许多优点，例如<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://www.cse.chalmers.se/~rjmh/Papers/whyfp.pdf">确保内存安全<span class="sr-only">（在新选项卡中打开）</span></a>和消除任意副作用。这使得系统分析和组合程序构建成为可能，从而促进可扩展和复杂软件系统的开发。然而，函数式编程的一个缺点是它倾向于随意分配新内存。我们认为这一特性阻碍了性能关键领域的广泛采用。我们如何克服这一限制并利用函数式编程的优势，同时保持高效的内存使用？</p><p>为了说明这个问题，让我们检查一下众所周知的函数程序，该程序使用累积参数在线性时间内反转列表： </p><figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_reverse-list-code-block-Koka.png" alt="FP2：完全就地函数式编程 - Koka 中的反向列表代码" class="wp-image-967419" style="width:450px" width="450" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_reverse-list-code-block-Koka.png 751w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_reverse-list-code-block-Koka-300x102.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_reverse-list-code-block-Koka-240x81.png 240w" sizes="(max-width: 751px) 100vw, 751px" /></figure><p>反转函数是用<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://koka-lang.github.io/" target="_blank" rel="noreferrer noopener">Koka <span class="sr-only">（在新选项卡中打开）</span></a>编写的，Koka 是 Microsoft 开发的一种函数式语言，用于实现本博客文章中描述的技术。这里，列表要么是空的（如<code><font color="#800000">Nil</font></code> ），要么是非空的<code><font color="#800000">Cons</font> (head,tail)</code>节点，并且包含第一个元素作为头，列表的其余部分作为<code>tail</code> 。</p><p>在大多数函数式语言中，以这种方式反转列表会在堆中分配一个新的结果列表，其中从 1 到 10 的整数列表被反转，如图 1 所示。 </p><figure class="wp-block-image aligncenter size-large is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig2-1024x950.png" alt="FP2：完全就地函数式编程；图 1 - 该图显示了两个单链表。第一个单链表包含数字 6 到 10，并由"xs." The second single-linked list contains the numbers 5 to 1 and is pointed to by "acc."" class="wp-image-964947" style="width:400px" width="400" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig2-1024x950.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig2-300x278.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig2-768x712.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig2-194x180.png 194w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig2.png 1065w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption class="wp-element-caption">图 1：列表 [1..5] 已经反转为 acc，但我们仍然必须反转列表 [6..10]。</figcaption></figure><p>由于列表<code>xs</code>非空，我们将其第一个元素添加到累积的<code>acc</code>参数中，然后再递归列表<code>xx</code>的其余部分。如图 2 所示，此步骤分配一个新的<code><font color="#800000">Cons</font></code>单元，但也会留下<code>xs</code>的<code><font color="#800000">Cons</font></code>单元进行垃圾回收。这是相当浪费的。 </p><figure class="wp-block-image aligncenter size-large is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig3-1024x978.png" alt="FP2：完全就地函数式编程；图 3 - 该图描绘了两个单链表。第一个单链表包含数字 7 到 10，并由"xs." Above the list, there is the list element containing the number 6, which is now up for deletion and is red. The second single-linked list contains the numbers 6 to 1 and is pointed to by "acc." The list element containing 6 is newly allocated and is green." class="wp-image-964950" style="width:400px" width="400" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig3-1024x978.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig3-300x287.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig3-768x734.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig3-188x180.png 188w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig3.png 1048w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption class="wp-element-caption">图 2：一级递归后的列表。左侧顶部的<code><font color="#800000">Cons</font></code>单元已成为垃圾，而右侧顶部的<code><font color="#800000">Cons</font></code>单元是新分配的。 </figcaption></figure><h2 class="wp-block-heading" id="fully-in-place-functional-programming-avoids-allocation">完全就地函数式编程避免了分配</h2><p>最近的发展使得避免此类分配成为可能。特别是，通过使用名为<a href="https://www.microsoft.com/en-us/research/publication/perceus-garbage-free-reference-counting-with-reuse-2/">Perceus</a>的编译器引导的引用计数算法，只要对象在运行时被唯一引用，我们就可以就地重用对象。通过这种重用，reverse 函数可以<em>就地</em>反转唯一的输入列表 xs，而无需分配任何新的<code><font color="#800000">Cons</font></code>节点，本质上是就地切换 xs 的尾指针。然而，这种重用形式的动态性质使得很难在运行时预测其应用程序。</p><p>在我们在<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://icfp23.sigplan.org/" target="_blank" rel="noreferrer noopener">ICFP 2023 <span class="sr-only">（</span></a> <a href="https://www.microsoft.com/en-us/research/publication/fp2-fully-in-place-functional-programming-2/"><span class="sr-only">在新选项卡中打开）</span>上展示的论文“FP <sup>2</sup> ：完全就地函数式编程（在</a>新选项卡中打开）”中，我们描述了新的<code><font color="#0000FF">fip</font></code>关键字。它静态地检查像累加反向函数这样的程序是否可以<em>就地</em>执行，也就是说，只要参数是唯一的，就可以使用常量堆栈空间，而不需要任何堆分配。 </p><div style="height:30px" aria-hidden="true" class="wp-block-spacer"></div><div class="border-bottom border-top border-gray-300 mt-5 mt-md-4 mb-4 mb-md-5 msr-promo text-center text-md-left alignwide" data-bi-aN="promo" data-bi-id="932112"><p class="msr-promo__label text-gray-800 text-center text-uppercase"><span class="px-4 bg-white display-inline-block font-weight-semibold small">焦点：微软研究院播客</span></p><div class="row pt-3 pb-4 align-items-center"><div class="msr-promo__media col-12 col-md-5"> <a class="bg-gray-300" href="https://www.microsoft.com/en-us/research/podcast/ai-frontiers-ai-for-health-and-the-future-of-research-with-peter-lee/" aria-label="AI Frontiers: AI for health and the future of research with Peter Lee" data-bi-cN="AI Frontiers: AI for health and the future of research with Peter Lee" target="_blank"><img decoding="async" class="w-100 display-block" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/03/PeterLee_podcast-2023Mar_hero_1400x788.png" alt="Peter Lee 戴着眼镜，对着镜头微笑，左侧有 Microsoft Research Podcast 徽标" /></a></div><div class="msr-promo__content p-3 px-5 col-12 col-md"><h2 class="h4"> AI 前沿：Peter Lee 的 AI 健康与研究的未来</h2><p class="large">微软研究院院长 Peter Lee 和 AI 科学家兼工程师 Ashley Llorens 讨论了 AI 研究的未来以及 GPT-4 作为医疗副驾驶的潜力。 </p><div class="wp-block-buttons justify-content-center justify-content-md-start"><div class="wp-block-button"> <a href="https://www.microsoft.com/en-us/research/podcast/ai-frontiers-ai-for-health-and-the-future-of-research-with-peter-lee/" class="btn btn-brand glyph-append glyph-append-chevron-right" aria-label="Listen now" data-bi-cN="AI Frontiers: AI for health and the future of research with Peter Lee" target="_blank">现在听</a></div></div></div><!--/.msr-promo__content--></div><!--/.msr-promo__inner-wrap--><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span></div><!--/.msr-promo--><h2 class="wp-block-heading" id="tree-traversals-and-zippers">树木遍历和拉链</h2><p>事实上，许多熟悉的函数和算法都满足我们完全就地的标准。例如，考虑一棵所有值都位于叶子的二叉树： </p><figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_binary-tree-code-block-Koka.png" alt="FP2：完全就地函数式编程 - Koka 中的二叉树代码" class="wp-image-967398" style="width:300px" width="300" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_binary-tree-code-block-Koka.png 501w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_binary-tree-code-block-Koka-300x67.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_binary-tree-code-block-Koka-240x54.png 240w" sizes="(max-width: 501px) 100vw, 501px" /></figure><p>现在，假设我们想要浏览这棵树，上下移动以搜索特定元素。您可以添加父指针，但在函数式语言中，有一种最初由 Gérard Huet 提出的替代解决方案，称为<em><a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://www.cambridge.org/core/journals/journal-of-functional-programming/article/zipper/0C058890B8A9B588F26E6D68CF0CE204" target="_blank" rel="noreferrer noopener">拉链<span class="sr-only">（在新选项卡中打开）</span></a></em> ： </p><figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_Zipper-code-block-Koka.png" alt="FP2：完全就地函数式编程 - Koka 中的 Zipper 代码" class="wp-image-967401" style="width:300px" width="300" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_Zipper-code-block-Koka.png 511w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_Zipper-code-block-Koka-300x89.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_Zipper-code-block-Koka-240x71.png 240w" sizes="(max-width: 511px) 100vw, 511px" /></figure><div class="annotations " data-bi-aN="margin-callout"><ul class="annotations__list card depth-16 bg-body p-4 annotations__list--right"><li class="annotations__list-item"> <span class="annotations__type d-block text-uppercase font-weight-semibold text-neutral-300 small">下载</span><a href="https://github.com/koka-lang/koka" target="_self" class="annotations__link font-weight-semibold text-decoration-none" data-bi-type="annotated-link" aria-label="Koka" data-bi-aN="margin-callout" data-bi-cN="Koka">Koka<span class="glyph-append glyph-append-share glyph-append-xsmall"></span></a></li></ul></div><p> zipper 沿着从当前节点到根节点的路径存储子树。我们可以定义由这种类型的拉链和当前树组成的对的操作，从而实现在树中的无缝移动。例如，以下函数使用拉链将焦点移动到左子树： </p><figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_left-subtree-code-block-Koka.png" alt="FP2：完全就地函数式编程 - 重点关注 Koka 中的左子树代码" class="wp-image-967395" style="width:480px" width="480" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_left-subtree-code-block-Koka.png 843w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_left-subtree-code-block-Koka-300x53.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_left-subtree-code-block-Koka-768x137.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_left-subtree-code-block-Koka-240x43.png 240w" sizes="(max-width: 843px) 100vw, 843px" /></figure><p>在这里，我们移动到当前节点的左子树（如果存在）并相应地扩展 zipper 数据类型。 Huet 在 1997 年就已经观察到这种拉链操作可以就地实施：</p><figure class="wp-block-pullquote"><blockquote><p><em>二叉树上的高效破坏性算法可以使用这些完全适用的原语进行编程，这些原语都使用恒定时间，因为它们都减少到本地指针操作</em>。</p></blockquote></figure><p>在 Koka 中，我们现在可以使 Huet 的直觉更加精确，其中<code><font color="#0000FF">fip</font></code>关键字保证<code>left</code>就位。仔细观察，这可能会令人惊讶。虽然列表反转示例重用了<code><font color="#800000">Cons</font></code>节点，但这里似乎我们可能需要垃圾收集<code><font color="#800000">Bin</font></code>构造函数并分配新的<code><font color="#800000">BinL</font></code>构造函数。尽管如此，由于两个构造函数都有两个字段，因此仍然可以重用之前的<code><font color="#800000">Bin</font></code>内存位置（仅更新构造函数标记）。我们的<a href="https://www.microsoft.com/en-us/research/publication/fp2-fully-in-place-functional-programming-2/" target="_blank" rel="noreferrer noopener">论文</a>提供了实现这一点的分析细节，植根于“重复使用积分”的概念。</p><p>现在，假设我们要更新存储在树中的所有值。使用拉链，我们可以完全就位做到这一点。遍历时，zipper 按顺序存储输入树片段，使用<code><font color="#800000">BinL</font></code>表示未访问的子树，使用<code><font color="#800000">BinR</font></code>表示已访问的子树。重用拉链节点允许有序树映射，而无需使用堆或堆栈。树映射函数首先下降到最左边的叶子，在<code><font color="#800000">BinL</font></code>中累积未访问的子树。一旦到达最左边的叶子，我们就应用参数函数 f 并向上返回，递归处理任何未访问的子树，如图 3 所示。 </p><figure class="wp-block-image size-full is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_unvisited-subtrees-code-block-Koka.png" alt="FP2：完全就地函数式编程 - Koka 中未访问的子树代码" class="wp-image-967392" style="width:540px" width="540" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_unvisited-subtrees-code-block-Koka.png 880w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_unvisited-subtrees-code-block-Koka-300x207.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_unvisited-subtrees-code-block-Koka-768x530.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/FiP_unvisited-subtrees-code-block-Koka-240x166.png 240w" sizes="(max-width: 880px) 100vw, 880px" /></figure><p>相互尾递归应用程序和向下功能已完全到位。每个<code><font color="#800000">Bin</font></code>与<code><font color="#800000">BinL</font></code>配对，每个<code><font color="#800000">BinL</font></code>与<code><font color="#800000">BinR</font></code> ，最终导致<code><font color="#800000">BinR</font></code>与<code><font color="#800000">Bin</font></code>配对。 <code>tmap</code>的定义可能看起来有些复杂，但它比使用直接指针反转的迭代命令式对应物要简单得多。 </p><figure class="wp-block-image aligncenter size-large is-resized"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1-1024x572.png" alt="FP2：完全就地函数式编程；图 3 - 二叉搜索树的图示，其中搜索路径已被指针反转。总共有五个节点：三个叶节点和两个内部节点。第一个叶节点是根的左子节点并且已经被访问过。根节点标记为"BinR" since our method descended into its right subtree. The root does not point to a right child, but instead its former right child points up to the root. This former child is marked "BinL" since our search descended into its left child, and its right child is an unvisited leaf. At this state of the program, our accumulator "acc" is the former right child of the root, and our current element "xs" is the former left child of the former right child of the root." class="wp-image-964944" style="width:400px" width="400" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1-1024x572.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1-300x168.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1-768x429.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1-343x193.png 343w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1-240x134.png 240w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/fip-blog-fig1.png 1502w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption class="wp-element-caption">图 3：访问​​给定树上包含 f(2) 的叶子后的程序。拉链上的指针是相反的。</figcaption></figure><h2 class="wp-block-heading" id="perspectives-and-further-reading">观点和进一步阅读</h2><p>Koka 的新<code><font color="#0000FF">fip</font></code>关键字确保某些函数不分配而仅使用常量堆栈空间，提供类似于静态线性类型或 Rust 借用检查器的高效且安全的代码执行。这引入了一种新的范例，用于编写纯函数式但仍可以就地执行的程序。我们认为这项新技术是使用高级函数式编程开发强大的软件以提供具有竞争力和可预测性能的道路上的一个重要里程碑。</p><p>要了解完全就地函数式编程和 Koka 语言，请从<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://koka-lang.github.io/koka/doc/index.html" target="_blank" rel="noreferrer noopener">Koka 主页<span class="sr-only">（在新选项卡中打开）</span></a>开始。 Koka 实现了各种创新的语言功能，包括代数效果处理程序和一流的构造函数上下文。我们鼓励读者继续探索和尝试完全就地编程。例如，尝试在 Koka 中实现<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://en.wikipedia.org/wiki/Skew_heap" target="_blank" rel="noreferrer noopener">倾斜二进制堆<span class="sr-only">（在新选项卡中打开）</span></a> 。您能演示完全就地堆联合吗？</p><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span><p><a rel="nofollow" href="https://www.microsoft.com/en-us/research/blog/fp2-fully-in-place-functional-programming-provides-memory-reuse-for-pure-functional-programs/">FP2：完全就地函数式编程为纯函数式程序提供内存重用后的文章</a>首先出现在<a rel="nofollow" href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>;</content:encoded></item><item><title>通过文本到图像生成镜头了解社会偏见</title><link/>https://www.microsoft.com/en-us/research/blog/understanding-social-biases-through-the-text-to-image- Generation-lens/<dc:creator><![CDATA[Alyssa Hughes]]></dc:creator><pubDate> Fri, 08 Sep 2023 16:00:00 +0000</pubDate><category><![CDATA[Research Blog]]></category><guid ispermalink="false"> https://www.microsoft.com/en-us/research/blog/understanding-social-biases-through-the-text-to-image- Generation-lens/ </guid><description><![CDATA[<p>人工智能生成的图像中的性别、种族和年龄差异仍然存在。这项 AIES 2023 关于文本到图像模型的研究表明，即使是基本的提示也可能导致代表性不足，因此需要采取负责任的偏见缓解策略。</p><p> <a rel="nofollow" href="https://www.microsoft.com/en-us/research/blog/understanding-social-biases-through-the-text-to-image-generation-lens/">《通过文本到图像生成镜头了解社会偏见》</a>一文首先出现在<a rel="nofollow" href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>; </description><content:encoded><![CDATA[
<p class="has-text-align-left"><strong><em>这篇研究论文在<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://www.aies-conference.com/2023/" target="_blank" rel="noreferrer noopener">第六届 AAAI/ACM 人工智能、伦理与社会会议 (AIES) <span class="sr-only">（在新选项卡中打开）</span></a>上发表，这是讨论人工智能社会和伦理方面的首要论坛。</em></strong> </p><figure class="wp-block-image size-full"><img decoding="async" width="1400" height="788" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/AIES-2023-BlogHeroFeature-1400x788-1.jpg" alt=""Microsoft at AIES 2023: Social Biases through the Text-to-Image Generation Lens" title to the left of the front page of said publication on a red, abstract background." class="wp-image-965313" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/AIES-2023-BlogHeroFeature-1400x788-1.jpg 1400w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/AIES-2023-BlogHeroFeature-1400x788-1-300x169.jpg 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/AIES-2023-BlogHeroFeature-1400x788-1-1024x576.jpg 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/AIES-2023-BlogHeroFeature-1400x788-1-768x432.jpg 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/AIES-2023-BlogHeroFeature-1400x788-1-1066x600.jpg 1066w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/AIES-2023-BlogHeroFeature-1400x788-1-655x368.jpg 655w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/AIES-2023-BlogHeroFeature-1400x788-1-343x193.jpg 343w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/AIES-2023-BlogHeroFeature-1400x788-1-240x135.jpg 240w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/AIES-2023-BlogHeroFeature-1400x788-1-640x360.jpg 640w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/AIES-2023-BlogHeroFeature-1400x788-1-960x540.jpg 960w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/AIES-2023-BlogHeroFeature-1400x788-1-1280x720.jpg 1280w" sizes="(max-width: 1400px) 100vw, 1400px" /></figure><p>文本转图像 (T2I) 技术的兴起开创了创新的新时代，为创作者、设计师和生产力软件的日常用户提供了广泛的可能性。这项技术可以将描述性文本转化为非常逼真的视觉内容，使用户能够通过生动的说明元素来丰富他们的工作。然而，这一创新背后隐藏着一个值得注意的问题——可能包含有害的社会偏见。</p><p>这些 T2I 模型根据他们所接受的广泛网络数据创建图像，而这些数据通常缺乏不同人口群体和文化的代表性，甚至可能隐藏有害内容。当这些社会偏见渗透到人工智能生成的内容中时，它们就会延续并放大先前存在的社会问题，加剧这些问题，并形成一个令人不安的循环，破坏以前和当前的缓解努力。 </p><h2 class="wp-block-heading" id="representation-of-gender-race-and-age-across-occupations-and-personality-traits">不同职业和性格特征中性别、种族和年龄的代表性</h2><p>为了解决这个问题，必须根据各种人口因素和场景严格评估这些模型。在我们在<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://www.aies-conference.com/2023/" target="_blank" rel="noreferrer noopener">AIES 2023 <span class="sr-only">（</span></a> <a href="https://www.microsoft.com/en-us/research/publication/social-biases-through-the-text-to-image-generation-lens/" target="_blank" rel="noreferrer noopener"><span class="sr-only">在新选项卡中打开）上发表的论文“文本到图像生成镜头中的社会偏见（</span></a>在新选项卡中打开）”中，我们进行了彻底的分析，以研究和量化生成的文本到图像生成镜头中反映的常见社会偏见。图片。我们专注于跨性别、年龄、种族和地理位置的职业、性格特征和日常情境的描绘。 </p><div style="height:20px" aria-hidden="true" class="wp-block-spacer"></div><div class="border-bottom border-top border-gray-300 mt-5 mt-md-4 mb-4 mb-md-5 msr-promo text-center text-md-left alignwide" data-bi-aN="promo" data-bi-id="932112"><p class="msr-promo__label text-gray-800 text-center text-uppercase"><span class="px-4 bg-white display-inline-block font-weight-semibold small">焦点：微软研究院播客</span></p><div class="row pt-3 pb-4 align-items-center"><div class="msr-promo__media col-12 col-md-5"> <a class="bg-gray-300" href="https://www.microsoft.com/en-us/research/podcast/ai-frontiers-ai-for-health-and-the-future-of-research-with-peter-lee/" aria-label="AI Frontiers: AI for health and the future of research with Peter Lee" data-bi-cN="AI Frontiers: AI for health and the future of research with Peter Lee" target="_blank"><img decoding="async" class="w-100 display-block" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/03/PeterLee_podcast-2023Mar_hero_1400x788.png" alt="Peter Lee 戴着眼镜，对着镜头微笑，左侧有 Microsoft Research Podcast 徽标" /></a></div><div class="msr-promo__content p-3 px-5 col-12 col-md"><h2 class="h4"> AI 前沿：Peter Lee 的 AI 健康与研究的未来</h2><p class="large">微软研究院院长 Peter Lee 和 AI 科学家兼工程师 Ashley Llorens 讨论了 AI 研究的未来以及 GPT-4 作为医疗副驾驶的潜力。 </p><div class="wp-block-buttons justify-content-center justify-content-md-start"><div class="wp-block-button"> <a href="https://www.microsoft.com/en-us/research/podcast/ai-frontiers-ai-for-health-and-the-future-of-research-with-peter-lee/" class="btn btn-brand glyph-append glyph-append-chevron-right" aria-label="Listen now" data-bi-cN="AI Frontiers: AI for health and the future of research with Peter Lee" target="_blank">现在听</a></div></div></div><!--/.msr-promo__content--></div><!--/.msr-promo__inner-wrap--><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span></div><!--/.msr-promo--><p>例如，考虑强化对首席执行官和管家角色的社会偏见的图像。这些职业作为陈规定型性别偏见的例子受到了广泛的研究——其中男性主要担任首席执行官，女性担任管家。对于所有此类案例，我们观察到三种不同的观点：</p><ol start="1"><li><strong>真实世界分布</strong>：依赖于劳动力统计数据，呈现性别、种族和年龄等各个维度的分布。</li></ol><ol start="2"><li><strong>搜索引擎结果</strong>：捕获搜索引擎结果中明显的分布，反映当代的描述。</li></ol><ol start="3"><li><strong>图像生成结果</strong>：强调图像生成输出中观察到的分布。</li></ol><p>我们测试了两种 T2I 生成器：DALLE-v2 和 Stable Diffusion，并将它们与美国劳工统计局 2022 年的数据以及 2020 年进行的 Google 图像搜索结果进行比较，研究女性在五种不同职业中的代表性。值得注意的是，与来自美国劳工统计局 (BLS) 和基于地理参考信息的网络图像搜索 (GIS) 的数据相比，对生成模型的分析揭示了代表性公平性的重大挫折。值得注意的是，DALLE-v2 生成的图像只提供了 CEO 和计算机程序员职业中女性的最少代表性。相反，在稳定扩散生成的图像中，女性在 100% 的时间里始终扮演护士和管家的角色。图 1 说明了我们的发现，图 2 显示了为显示不同职业而生成的图像示例。</p><figure class="wp-block-image aligncenter size-full is-resized"> <a href="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_1.png"><img decoding="async" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_1.png" alt="该图表显示了 DALLE-v2、Stable Diffusion、Google Image Search 2020 和 BLS 数据的性别代表性百分比。" class="wp-image-965334" style="width:514px;height:410px" width="514" height="410" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_1.png 2385w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_1-300x240.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_1-1024x818.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_1-768x613.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_1-1536x1227.png 1536w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_1-2048x1636.png 2048w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_1-225x180.png 225w" sizes="(max-width: 514px) 100vw, 514px" /></a><figcaption class="wp-element-caption">图 1.DALLE-v2、稳定扩散、Google 图像搜索 2020 和 BLS 数据的性别表示。</figcaption></figure><figure class="wp-block-image aligncenter size-full"> <a href="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_2.png"><img decoding="async" loading="lazy" width="4819" height="1409" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_2.png" alt="使用 DALL-E v2 和稳定扩散模型的“计算机程序员”和“管家”职业的世代示例。" class="wp-image-965337" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_2.png 4819w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_2-300x88.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_2-1024x299.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_2-768x225.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_2-1536x449.png 1536w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_2-2048x599.png 2048w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_2-240x70.png 240w" sizes="(max-width: 4819px) 100vw, 4819px" /></a><figcaption class="wp-element-caption">图 2. 使用 DALL-E v2 和稳定扩散模型为“计算机程序员”和“管家”职业生成的前四张图像的示例。值得注意的是，在 500 张生成的图像分布中明显缺少一种性别。</figcaption></figure><p>即使使用“人”等基本提示而不包含职业，我们也观察到模型可能无法代表跨年龄、种族和性别的某些人口群体。当我们分析 DALLE-v2 和稳定扩散时，两者都在一组 500 个生成的图像中提供了除白人之外的有限种族代表。此外，DALLE-v2 输出显示年龄多样性明显缺乏，超过 80% 的图像描绘的是年龄在 18 岁至 40 岁之间的成年人或儿童。图 3 对此进行了说明。</p><figure class="wp-block-image aligncenter size-large"> <a href="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/Social-Biases-Through-the-Text-to-Image-Lense-560x1921-1.png"><img decoding="async" loading="lazy" width="1024" height="576" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/Social-Biases-Through-the-Text-to-Image-Lense-560x1921-1-1024x576.png" alt="三张图表显示了 DALL-E v2 和稳定扩散模型的人类注释者所解释的性别、种族和年龄分布。" class="wp-image-965310" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/Social-Biases-Through-the-Text-to-Image-Lense-560x1921-1-1024x576.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/Social-Biases-Through-the-Text-to-Image-Lense-560x1921-1-300x169.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/Social-Biases-Through-the-Text-to-Image-Lense-560x1921-1-768x432.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/Social-Biases-Through-the-Text-to-Image-Lense-560x1921-1-1066x600.png 1066w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/Social-Biases-Through-the-Text-to-Image-Lense-560x1921-1-655x368.png 655w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/Social-Biases-Through-the-Text-to-Image-Lense-560x1921-1-343x193.png 343w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/Social-Biases-Through-the-Text-to-Image-Lense-560x1921-1-240x135.png 240w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/Social-Biases-Through-the-Text-to-Image-Lense-560x1921-1-640x360.png 640w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/Social-Biases-Through-the-Text-to-Image-Lense-560x1921-1-960x540.png 960w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/Social-Biases-Through-the-Text-to-Image-Lense-560x1921-1-1280x720.png 1280w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/Social-Biases-Through-the-Text-to-Image-Lense-560x1921-1.png 1400w" sizes="(max-width: 1024px) 100vw, 1024px" /></a><figcaption class="wp-element-caption">图 3. 人类注释者解释的性别、种族和年龄分布以及在提示“人”的图像生成背景下的自动面部处理。</figcaption></figure><p>我们的研究还研究了积极和消极人格特征的相似表征的偏差，揭示了如何描述这些特征的微妙之处。虽然非白人种族的个体似乎与活力、雄心、奋斗和独立等积极品质有关，但他们也与冷漠、冷酷和自负等消极品质有关。 </p><h2 class="wp-block-heading" id="representation-of-geographical-locations-in-everyday-scenarios">日常生活场景中地理位置的表示</h2><p>我们研究的偏见的另一个方面涉及模型如何解释日常场景中不同地理位置的表示。我们使用“生日聚会的照片”或“图书馆的照片”等提示来做到这一点。尽管很难辨别生成的照片的精确位置，但仍然可以在使用一般提示和指定位置的提示（例如“哥伦比亚生日聚会的照片”）之间衡量这些表示的区别。在本文中，我们描述了每个有人居住的大陆上两个人口最多的国家的实验，考虑了围绕事件、地点、食物、机构、社区和服装的日常场景。当模型给出一般提示时，总体结果表明，为尼日利亚、巴布亚新几内亚和埃塞俄比亚等国家生成的图像在提示和图像之间差异最大，而为德国、美国和俄罗斯生成的图像最接近与一般提示一致。</p><h2 class="wp-block-heading" id="subtle-effects-of-using-expanded-prompts">使用扩展提示的微妙效果</h2><p>许多偏差缓解技术依赖于扩展提示来丰富和多样化模型生成的图像。为了解决人工智能生成图像中的偏差，我们应用了<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://learn.microsoft.com/en-us/azure/ai-services/openai/concepts/advanced-prompt-engineering?pivots=programming-language-chat-completions" target="_blank" rel="noreferrer noopener">提示工程<span class="sr-only">（在新选项卡中打开）</span></a>来增加图像反映提示中指定内容的可能性。我们使用提示扩展（一种提示工程）来向初始一般提示添加更多描述符，并引导模型走向公正的内容。快速扩展的一个例子是“女医生的肖像”而不是“医生的肖像”。我们的实验证明，即时扩展对于在人工智能生成的图像中创建更具体的内容非常有效。然而，也存在意想不到的结果，特别是在多样性和图像质量下降方面，如图 4 所示。</p><figure class="wp-block-image aligncenter size-full"> <a href="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_4.png"><img decoding="async" loading="lazy" width="3511" height="2005" src="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_4.png" alt="DALL-E v2 针对两个提示的生成输出示例：“播音员肖像”和“女播音员肖像”。" class="wp-image-965343" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_4.png 3511w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_4-300x171.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_4-1024x585.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_4-768x439.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_4-1536x877.png 1536w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_4-2048x1170.png 2048w, https://www.microsoft.com/en-us/research/uploads/prod/2023/09/figure_4-240x137.png 240w" sizes="(max-width: 3511px) 100vw, 3511px" /></a><figcaption class="wp-element-caption">图 4. 使用“女性”等描述符的扩展提示确实可以产生更多样化的描述，但通常以图像多样性和质量为代价。</figcaption></figure><h2 class="wp-block-heading" id="safeguarding-against-bias-in-t2i-models">防止 T2I 模型中出现偏差</h2><p>随着 T2I 一代模型越来越多地融入我们的数字生态系统，我们必须对它们可能无意中延续的偏见保持警惕，这一点至关重要。这项研究强调了不断评估和完善这些模型的重要性。我们希望本研究中提出的结果和方法为评估和构建新的生成模型提供有价值的见解。我们想强调在此过程中促进负责任的发展和确保代表性公平的重要性。</p><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span><p><a rel="nofollow" href="https://www.microsoft.com/en-us/research/blog/understanding-social-biases-through-the-text-to-image-generation-lens/">《通过文本到图像生成镜头了解社会偏见》</a>一文首先出现在<a rel="nofollow" href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>;</content:encoded></item></channel></rss>