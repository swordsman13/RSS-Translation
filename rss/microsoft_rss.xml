<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:wfw="http://wellformedweb.org/CommentAPI/"><channel><title>微软研究院博客 - 微软研究院</title><atom:link href="https://www.microsoft.com/en-us/research/blog/feed/?from=https%3A%2F%2Fresearch.microsoft.com%2Frss%2Fnews.xml&amp;type=rss" rel="self" type="application/rss+xml"></atom:link><link/> https://www.microsoft.com/en-us/research/blog/<description></description><lastbuilddate> 2024 年 12 月 16 日星期一 21:16:55 +0000</lastbuilddate><language> en-US</language><sy:updateperiod>每小时</sy:updateperiod><sy:updatefrequency>1</sy:updatefrequency><generator> https://wordpress.org/?v=6.7.1</generator><item><title> PromptWizard：通过反馈驱动的自我进化提示进行提示优化的未来</title><link/>https://www.microsoft.com/en-us/research/blog/promptwizard-the-future-of-prompt-optimization-through-feedback-driven-self-evolving-prompts/<dc:creator><![CDATA[Brenda Potts]]></dc:creator><pubDate> Tue, 17 Dec 2024 17:00:00 +0000</pubDate><category><![CDATA[Research Blog]]></category><guid ispermalink="false"> https://www.microsoft.com/en-us/research/?p=1111329 </guid><description><![CDATA[<p>微软研究院的 PromptWizard 现已开源。它旨在自动化和简化 AI 提示优化，将迭代的 LLM 反馈与高效的探索和细化技术相结合，在几分钟内创建高效的提示。</p><p> <a href="https://www.microsoft.com/en-us/research/blog/promptwizard-the-future-of-prompt-optimization-through-feedback-driven-self-evolving-prompts/">《PromptWizard：通过反馈驱动的自我进化提示实现提示优化的未来》</a>一文首先出现在<a href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>; </description><content:encoded><![CDATA[
<figure class="wp-block-image size-full"><img fetchpriority="high" decoding="async" width="1400" height="788" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard-BlogHeroFeature-1400x788-1.png" alt="说明 PromptWizard 中指令和上下文示例的联合优化过程的图表。该图展示了该框架如何迭代地完善这两个组件，整合反馈以增强跨任务的整体及时有效性和适应性。" class="wp-image-1111944" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard-BlogHeroFeature-1400x788-1.png 1400w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard-BlogHeroFeature-1400x788-1-300x169.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard-BlogHeroFeature-1400x788-1-1024x576.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard-BlogHeroFeature-1400x788-1-768x432.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard-BlogHeroFeature-1400x788-1-1066x600.png 1066w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard-BlogHeroFeature-1400x788-1-655x368.png 655w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard-BlogHeroFeature-1400x788-1-240x135.png 240w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard-BlogHeroFeature-1400x788-1-640x360.png 640w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard-BlogHeroFeature-1400x788-1-960x540.png 960w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard-BlogHeroFeature-1400x788-1-1280x720.png 1280w" sizes="(max-width: 1400px) 100vw, 1400px" /></figure><h2 class="wp-block-heading" id="the-challenge-of-effective-prompting">有效提示的挑战</h2><p>得益于大语言模型 (LLM) 的进步，人工智能正在重塑从教育到医疗保健的各个行业。这些模型依赖于提示和精心设计的输入，指导它们产生相关且有意义的输出。虽然提示的影响是深远的，但创建有助于完成复杂任务的提示是一个耗时且需要大量专业知识的过程，通常需要数月的反复试验。</p><p>随着新任务的出现和模型的快速发展，这一挑战日益严峻，使得快速工程的手动方法越来越不可持续。那么问题就变成了：<strong>我们如何才能使即时优化更快、更容易、更适应不同的任务？</strong> </p><div class="annotations " data-bi-aN="margin-callout"><ul class="annotations__list card depth-16 bg-body p-4 annotations__list--right"><li class="annotations__list-item"> <span class="annotations__type d-block text-uppercase font-weight-semibold text-neutral-300 small">下载</span><a href="https://github.com/microsoft/PromptWizard" target="_blank" class="annotations__link font-weight-semibold text-decoration-none" data-bi-type="annotated-link" aria-label="PromptWizard" data-bi-aN="margin-callout" data-bi-cN="PromptWizard">提示向导<span class="glyph-append glyph-append-share glyph-append-xsmall"></span></a></li></ul></div><p>为了应对这一挑战，我们开发了 PromptWizard (PW)，这是一个研究框架，可以自动化并简化提示优化过程。我们正在开源<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://github.com/microsoft/PromptWizard" target="_blank" rel="noreferrer noopener">PromptWizard 代码库<span class="sr-only">（在新选项卡中打开），</span></a>以促进研发社区内的协作和创新。</p><h2 class="wp-block-heading" id="introducing-promptwizard">提示向导简介</h2><p>PromptWizard (PW) 旨在<strong>自动化和简化提示优化</strong>。它将法学硕士的迭代反馈与高效的探索和细化技术相结合，可<strong>在几分钟内创建高效的提示</strong>。</p><p> <strong>PromptWizard 优化了指令和情境学习示例。</strong> PW 的核心是其自我进化和自适应机制，法学硕士可以迭代地生成、批评和完善提示和示例。此过程确保通过反馈和综合进行持续改进，实现针对当前特定任务的整体优化。通过同时改进指令和示例，PW 确保了任务性能的显着提高。</p><p> <strong>PromptWizard 背后的三个关键见解</strong>：</p><ul class="wp-block-list"><li><em>反馈驱动的细化：</em> PW 的核心是利用迭代反馈循环，法学硕士在其中生成、批评和细化自己的提示和示例。这种持续改进机制确保每次迭代都比上一次更好，从而产生高效的提示和示例。</li><li><em>不同示例的联合优化和合成：</em> PW 生成的合成示例不仅具有鲁棒性和多样性，而且具有任务感知能力。通过一起优化提示和示例，确保它们协同工作，有效地解决特定的任务要求。</li><li><em>自生成的思想链（CoT）步骤</em>：结合CoT推理提高了模型解决问题的能力。通过使用选定的少数样本，PW 为每个示例生成详细的推理链，从而促进细致入微且逐步解决问题的方法。 </li></ul><figure class="wp-block-image aligncenter size-full"><img decoding="async" width="982" height="306" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-1.png" alt="图 1：提供 PromptWizard 流程概述的图表。它说明了主要组成部分，包括迭代提示生成、基于反馈的细化以及指令和示例的联合优化。该工作流程强调模块化和适应性，展示了 PromptWizard 如何改进提示以提高不同任务的性能。" class="wp-image-1111362" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-1.png 982w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-1-300x93.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-1-768x239.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-1-240x75.png 240w" sizes="(max-width: 982px) 100vw, 982px" /><figcaption class="wp-element-caption">图 1. PromptWizard 概述</figcaption></figure><h2 class="wp-block-heading" id="how-promptwizard-works">PromptWizard 的工作原理</h2><p>PromptWizard 从用户输入开始：问题描述、初始提示说明以及一些作为手头任务基础的培训示例。</p><p>其输出是一组精致、优化的提示指令，并配有精心策划的上下文中的少数示例。这些输出丰富了详细的推理链、任务意图和专家档案，将类人推理与人工智能的响应联系起来。</p><p><strong>第一阶段：及时指导的细化</strong></p><p>第一阶段的重点是完善提示的任务说明。 PromptWizard 生成多个候选指令，使用法学硕士的反馈对其进行评估，并迭代地合成改进的版本。这个过程平衡了<strong>探索</strong>（尝试不同的想法）和<strong>利用</strong>（完善最有前途的想法）。</p><p>例如，如果初始指令产生次优结果，PW 会结合反馈来识别其缺点并生成改进版本。经过三到五次迭代，该迭代周期可确保指令收敛到最佳状态。 </p><figure class="wp-block-image aligncenter size-full"><img decoding="async" width="1404" height="697" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-2.png" alt="图 2：PromptWizard 中提示指令的细化过程的可视化。该图突出显示了迭代改进，其中对初始指令进行批评，根据反馈进行调整，并进行微调以实现更高的准确性并与任务目标保持一致。" class="wp-image-1111365" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-2.png 1404w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-2-300x149.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-2-1024x508.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-2-768x381.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-2-240x119.png 240w" sizes="(max-width: 1404px) 100vw, 1404px" /><figcaption class="wp-element-caption">图2. 提示指令的细化</figcaption></figure><p><strong>第二阶段：指令和示例的联合优化</strong></p><p>第一阶段得到的细化提示与精心挑选的示例相结合，共同优化。通过批判与综合机制，PromptWizard 确保提示与示例之间的一致性，同时综合新的示例以提高任务性能。</p><p>这种结构化方法使 PromptWizard 具有高度通用性，可以适应解决数学问题或生成创意内容等各种任务。 </p><figure class="wp-block-image aligncenter size-full"><img loading="lazy" decoding="async" width="1128" height="504" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-3.png" alt="图 3：说明 PromptWizard 中指令和上下文示例的联合优化过程的图表。该图展示了该框架如何迭代地完善这两个组件，整合反馈以增强跨任务的整体及时有效性和适应性。" class="wp-image-1111368" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-3.png 1128w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-3-300x134.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-3-1024x458.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-3-768x343.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-3-240x107.png 240w" sizes="auto, (max-width: 1128px) 100vw, 1128px" /><figcaption class="wp-element-caption">图 3. 指令和示例的联合优化</figcaption></figure><div class="border-bottom border-top border-gray-300 mt-5 mb-5 msr-promo text-center text-md-left alignwide" data-bi-aN="promo" data-bi-id="1085514"><p class="msr-promo__label text-gray-800 text-center text-uppercase"><span class="px-4 bg-white display-inline-block font-weight-semibold small">焦点：博客文章</span></p><div class="row pt-3 pb-4 align-items-center"><div class="msr-promo__media col-12 col-md-5"> <a class="bg-gray-300" href="https://www.microsoft.com/en-us/research/blog/graphrag-auto-tuning-provides-rapid-adaptation-to-new-domains/" aria-label="GraphRAG auto-tuning provides rapid adaptation to new domains" data-bi-cN="GraphRAG auto-tuning provides rapid adaptation to new domains" target="_blank"><img decoding="async" class="w-100 display-block" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/09/GraphRag-3-BlogHeroFeature-1400x788-1.png" alt="蓝色到绿色渐变的 GraphRAG 图像" /></a></div><div class="msr-promo__content p-3 px-5 col-12 col-md"><h2 class="h4"> GraphRAG 自动调优可快速适应新领域</h2><p class="large">GraphRAG 使用 LLM 生成的知识图来大幅改进检索增强生成 (RAG) 的复杂问答。了解 GraphRAG 针对新数据集的自动调整，使其更加准确和相关。 </p><div class="wp-block-buttons justify-content-center justify-content-md-start"><div class="wp-block-button"> <a href="https://www.microsoft.com/en-us/research/blog/graphrag-auto-tuning-provides-rapid-adaptation-to-new-domains/" class="btn btn-brand glyph-append glyph-append-chevron-right" aria-label="Read more" data-bi-cN="GraphRAG auto-tuning provides rapid adaptation to new domains" target="_blank">阅读更多</a></div></div></div><!--/.msr-promo__content--></div><!--/.msr-promo__inner-wrap--><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span></div><!--/.msr-promo--><h2 class="wp-block-heading" id="results">结果</h2><p>PromptWizard 以其反馈驱动的改进和系统探索而脱颖而出，在保持计算效率的同时，在各种任务中提供卓越的结果。</p><h3 class="wp-block-heading" id="comprehensive-evaluation-across-tasks">跨任务综合评价</h3><p>PromptWizard 经过了超过 45 项任务的严格评估，涵盖一般挑战和特定领域的挑战。以最先进的技术（包括 Instinct、InstructZero、APE、PromptBreeder、EvoPrompt、DSPy、APO 和 PromptAgent）为基准，PW 在准确性、效率和适应性方面始终优于竞争对手。请参阅<a href="https://www.microsoft.com/en-us/research/publication/promptwizard-task-aware-agent-driven-prompt-optimization-framework/" target="_blank" rel="noreferrer noopener">我们论文</a>中的详细结果。</p><ul class="wp-block-list"><li><strong>准确性</strong>：PW 始终优于其他方法，在所有任务中保持接近最佳的性能。图 4 显示的性能曲线曲线突出了 PW 的可靠性，展示了与 BigBench 指令归纳数据集 (BBII) 的其他方法相比，它实现接近最佳准确度的频率。</li><li><strong>效率</strong>：除了准确性之外，PW 还展示了其计算效率。与许多需要大量 API 调用和计算资源的基线方法不同，PW 通过在探索和利用之间取得有效平衡，以最小的开销实现了卓越的结果。表 1 展示了 PW 的成本效益，显着减少了输入和输出的令牌使用量，同时有效优化了提示。 </li></ul><figure class="wp-block-image aligncenter size-full"><img loading="lazy" decoding="async" width="684" height="484" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-4.png" alt="图 4：性能曲线曲线显示了 PromptWizard 在 BigBench 指令归纳 (BBII) 数据集上的可靠性。该曲线显示了与其他方法相比，PromptWizard 实现接近最佳性能的准确度水平的频率，突出了其一致性和有效性。" class="wp-image-1111359" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-4.png 684w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-4-300x212.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/PromptWizard_Fig-4-240x170.png 240w" sizes="auto, (max-width: 684px) 100vw, 684px" /><figcaption class="wp-element-caption">图 4. BBII 数据集上的性能曲线</figcaption></figure><figure class="wp-block-table"><table class="has-fixed-layout"><thead><tr><th>方法</th><th>API调用</th><th>代币总数</th></tr></thead><tbody><tr><td>本能</td><td>1730</td><td> 115k</td></tr><tr><td>及时饲养员</td><td>18600</td><td> 1488k</td></tr><tr><td>进化提示</td><td>5000</td><td> 40万</td></tr><tr><td><strong>密码</strong></td><td><strong>69</strong></td><td> <strong>24k</strong></td></tr></tbody></table><figcaption class="wp-element-caption">表1. BBII数据集的成本分析</figcaption></figure><p>我们还进行了大量实验，以突出 PromptWizard 在有限的训练数据和较小的法学硕士的情况下的功效。</p><h3 class="wp-block-heading" id="resilience-with-limited-data">数据有限的弹性</h3><p>现实场景往往缺乏丰富的训练数据。 PW 在这种情况下表现出色，只需五个示例即可产生有效的提示。在五个不同的数据集中，与使用 25 个示例相比，使用 5 个示例时 PW 的平均准确率仅下降 5%，这凸显了其适应性和效率（参见表 2）。</p><figure class="wp-block-table"><table class="has-fixed-layout"><thead><tr><th>数据集</th><th>5个例子</th><th>25个例子</th></tr></thead><tbody><tr><td>MMLU</td><td> 80.4</td><td> 89.5</td></tr><tr><td> GSM8k</td><td> 94</td><td> 95.4</td></tr><tr><td>精神</td><td>86.4</td><td> 89.4</td></tr><tr><td>公共医学质量保证</td><td>68</td><td> 78.2</td></tr><tr><td>医学质量保证</td><td>80.4</td><td> 82.9</td></tr><tr><td><strong>平均的</strong></td><td><strong>81.9</strong></td><td> <strong>87</strong></td></tr></tbody></table><figcaption class="wp-element-caption">表 2. PW 在不同示例数量下的性能</figcaption></figure><h3 class="wp-block-heading" id="leveraging-smaller-models-for-optimization"> 利用较小的模型进行优化</h3><p>PromptWizard 还通过使用较小的 LLM 进行提示生成来降低计算成本，并保留更强大的模型进行推理。例如，与 GPT-4 相比，使用 Llama-70B 进行提示生成的性能差异可以忽略不计，同时显着降低了资源使用量（参见表 3）。</p><figure class="wp-block-table"><table class="has-fixed-layout"><thead><tr><th>数据集</th><th>提示生成器：Llama-70B</th><th>提示生成：GPT4</th></tr></thead><tbody><tr><td> GSM8k</td><td> 94.6</td><td> 95.4</td></tr><tr><td>精神</td><td>89.2</td><td> 89.4</td></tr><tr><td><strong>平均的</strong></td><td><strong>91.9</strong></td><td> <strong>92.4</strong></td></tr></tbody></table><figcaption class="wp-element-caption">表 3. 较小 LLM 的提示生成性能</figcaption></figure><p>PromptWizard 表明，有效的提示结合了通过迭代反馈、精心选择的上下文示例以及包含专家知识和特定任务意图的模块化设计而完善的优化指令。这种方法使框架能够处理从简单到高度复杂的广泛任务，并具有卓越的效率和灵活性。</p><p>无论您是解决前沿挑战的研究人员还是寻求简化工作流程的组织，PromptWizard 都能提供实用、可扩展且有影响力的解决方案来增强模型性能。</p><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span><p><a href="https://www.microsoft.com/en-us/research/blog/promptwizard-the-future-of-prompt-optimization-through-feedback-driven-self-evolving-prompts/">《PromptWizard：通过反馈驱动的自我进化提示实现提示优化的未来》</a>一文首先出现在<a href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>;</content:encoded></item><item><title>转向 GraphRAG 1.0 – 为开发人员和用户简化人体工程学</title><link/>https://www.microsoft.com/en-us/research/blog/moving-to-graphrag-1-0-streamlined-ergonomics-for-developers-and-users/<dc:creator><![CDATA[Brenda Potts]]></dc:creator><pubDate> Mon, 16 Dec 2024 17:00:00 +0000</pubDate><category><![CDATA[Research Blog]]></category><guid ispermalink="false"> https://www.microsoft.com/en-us/research/?p=1111143 </guid><description><![CDATA[<p> GraphRAG 有助于推进人工智能在科学等复杂领域的应用。由于热烈的采用和社区的参与，我们升级了预发布版本。查看 GraphRAG 1.0 中主要的人体工程学和结构更新。</p><p> <a href="https://www.microsoft.com/en-us/research/blog/moving-to-graphrag-1-0-streamlining-ergonomics-for-developers-and-users/">《转向 GraphRAG 1.0 – 为开发人员和用户简化人体工程学》</a>一文首先出现在<a href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>; </description><content:encoded><![CDATA[
<figure class="wp-block-image size-full"><img loading="lazy" decoding="async" width="1400" height="788" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/12/GraphRAG-1.0-BlogHeroFeature-1400x788-1.png" alt="GraphRAG 博客英雄 - 蓝色/绿色渐变背景上的小圆形节点簇" class="wp-image-1111170" srcset="https://www.microsoft.com/en-us/research/uploads/prod/2024/12/GraphRAG-1.0-BlogHeroFeature-1400x788-1.png 1400w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/GraphRAG-1.0-BlogHeroFeature-1400x788-1-300x169.png 300w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/GraphRAG-1.0-BlogHeroFeature-1400x788-1-1024x576.png 1024w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/GraphRAG-1.0-BlogHeroFeature-1400x788-1-768x432.png 768w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/GraphRAG-1.0-BlogHeroFeature-1400x788-1-1066x600.png 1066w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/GraphRAG-1.0-BlogHeroFeature-1400x788-1-655x368.png 655w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/GraphRAG-1.0-BlogHeroFeature-1400x788-1-240x135.png 240w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/GraphRAG-1.0-BlogHeroFeature-1400x788-1-640x360.png 640w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/GraphRAG-1.0-BlogHeroFeature-1400x788-1-960x540.png 960w, https://www.microsoft.com/en-us/research/uploads/prod/2024/12/GraphRAG-1.0-BlogHeroFeature-1400x788-1-1280x720.png 1280w" sizes="auto, (max-width: 1400px) 100vw, 1400px" /></figure><h2 class="wp-block-heading" id="introducing-graphrag-1-0"> GraphRAG 1.0 简介</h2><p>Microsoft 于 2024 年 7 月<a href="https://www.microsoft.com/en-us/research/blog/graphrag-new-tool-for-complex-data-discovery-now-on-github/" target="_blank" rel="noreferrer noopener">首次推出<span class="sr-only">（在新选项卡中打开）</span></a> <a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://github.com/microsoft/graphrag" target="_blank" rel="noreferrer noopener">GraphRAG 的预发布版本<span class="sr-only">（在新选项卡中打开），</span></a>以推进 AI 在复杂领域的使用。从那时起，我们看到了令人难以置信的采用和社区参与（截至撰写本文时，GitHub 上有超过 20k 个 star 和 2k 个 fork），核心团队和社区贡献者进行了大量修复和改进。我们对收到的贡献和反馈深表感谢，并很高兴与大家分享一些重大的人体工程学和结构改进，这些改进最终导致 GraphRAG 1.0 的正式发布。</p><h2 class="wp-block-heading" id="ergonomic-refactors">人体工学重构</h2><h3 class="wp-block-heading" id="easier-setup-for-new-projects">更轻松地设置新项目</h3><p>当我们第一次启动 GraphRAG 时，大多数配置都是使用环境变量完成的，考虑到可用的选项很多，这可能会令人望而生畏。我们通过添加<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://microsoft.github.io/graphrag/config/init/" target="_blank" rel="noreferrer noopener">init 命令<span class="sr-only">（在新选项卡中打开）</span></a>减少了设置过程中的麻烦，该命令生成一个简化的启动器 settings.yml 文件，其中所有核心所需的配置都已设置。我们建议开发人员从这里开始，以确保他们获得最清晰的初始配置。通过此更新，最小的启动配置不需要用户具备 GraphRAG 的专业知识即可快速设置，只需要在其环境中使用 OpenAI API 密钥。</p><h3 class="wp-block-heading" id="new-and-expanded-command-line-interface">新的和扩展的命令行界面</h3><p>我们扩展了<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://microsoft.github.io/graphrag/cli/" target="_blank" rel="noreferrer noopener">命令行界面<span class="sr-only">（在新选项卡中打开）</span></a> (CLI) 的功能和易用性，并采用了<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://github.com/fastapi/typer" target="_blank" rel="noreferrer noopener">Typer <span class="sr-only">（在新选项卡中打开）</span></a>来提供更好的内联文档和更丰富的 CLI 体验。最初的 CLI 旨在作为入门演示，供用户在示例数据集上尝试 GraphRAG。我们从社区了解到，大多数人实际上希望使用它作为 GraphRAG 的主要交互模式，因此作为这个里程碑版本的一部分，我们引入了增强功能，从而带来更简化的体验。通过这项工作，CLI 启动时间从平均 148 秒缩短到 2 秒。</p><h3 class="wp-block-heading" id="consolidated-api-layer">整合API层</h3><p>2024 年 8 月，我们引入了独立的 API 层来简化开发人员的使用。原始 CLI 包含实例化和执行基本索引和查询命令所需的所有代码，用户经常需要复制这些代码。当我们收集反馈时，API 层仍然被认为是临时的，但旨在成为希望将 GraphRAG 功能集成到自己的应用程序中而无需深度管道或查询类自定义的开发人员的主要入口点。事实上，CLI 和<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://github.com/azure-samples/graphrag-accelerator" target="_blank" rel="noreferrer noopener">加速器<span class="sr-only">（在新选项卡中打开）</span></a>完全构建在 API 层之上，充当如何与 API 交互的文档示例。我们还在我们的<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://microsoft.github.io/graphrag/query/notebooks/overview/" target="_blank" rel="noreferrer noopener">笔记本集合中添加了如何使用此 API 的示例<span class="sr-only">（在新选项卡中打开）</span></a> ，我们将在未来版本中迭代时继续更新这些示例。</p><h3 class="wp-block-heading" id="simplified-data-model">简化的数据模型</h3><p>GraphRAG 创建多个输出工件来存储索引知识模型。初始模型包含大量基于早期研究期间实验想法的文件、字段和交叉引用，这对于新用户和常规用户来说可能是难以承受的。我们对数据模型进行了全面审查，并进行了修复，以提高清晰度和一致性、删除冗余或未使用的字段、改善存储空间并简化数据模型。以前，输出缺乏标准化，相关输出很容易与非关键中间输出文件混淆。现在，使用 GraphRAG 1.0，输出将仅包括易于读取和追踪的相关输出。 </p><div class="border-bottom border-top border-gray-300 mt-5 mb-5 msr-promo text-center text-md-left alignwide" data-bi-aN="promo" data-bi-id="1061244"><div class="row pt-3 pb-4 align-items-center"><div class="msr-promo__media col-12 col-md-5"> <a class="bg-gray-300" href="https://www.microsoft.com/en-us/research/about-microsoft-research/" aria-label="About Microsoft Research" data-bi-cN="About Microsoft Research" target="_blank"><img decoding="async" class="w-100 display-block" src="https://www.microsoft.com/en-us/research/uploads/prod/2024/07/About-page-promo_1066x600.jpg" alt="" /></a></div><div class="msr-promo__content p-3 px-5 col-12 col-md"><h2 class="h4">关于微软研究院</h2><p class="large">推动科学技术造福人类</p><div class="wp-block-buttons justify-content-center justify-content-md-start"><div class="wp-block-button"> <a href="https://www.microsoft.com/en-us/research/about-microsoft-research/" class="btn btn-brand glyph-append glyph-append-chevron-right" aria-label="View our story" data-bi-cN="About Microsoft Research" target="_blank">查看我们的故事</a></div></div></div><!--/.msr-promo__content--></div><!--/.msr-promo__inner-wrap--><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span></div><!--/.msr-promo--><h3 class="wp-block-heading" id="streamlined-vector-stores">简化的矢量存储</h3><p>嵌入及其矢量存储是 GraphRAG 存储需求的一些主要驱动因素。我们的原始数据模型在数据摄取和索引后将所有嵌入存储在 parquet 输出文件中。这使得文件可移植，这对于早期研究来说很方便，但对于许多用户来说，随着他们配置自己的矢量存储并且数据摄取规模不断增长，这变得不必要。我们更新了 GraphRAG 管道，以<em>在索引期间创建默认向量存储，</em>因此不需要后处理，并且查询库共享此配置以实现无缝使用。此更改的好处是，从磁盘读取输出文件时不再需要加载这些向量（可能非常大），从而在每次查询期间节省读取时间和内存。再加上简化的数据模型，输出 Parquet 磁盘节省了 80%，总磁盘空间（包括矢量存储中的嵌入）减少了 43%。 GraphRAG 支持开箱即用的向量存储 LanceDB 和 Azure AI 搜索。为了简单启动，默认使用 LanceDB，并与知识模型工件一起写入本地数据库。</p><h3 class="wp-block-heading" id="flatter-clearer-code-structure">更扁平、更清晰的代码结构</h3><p>通往 1.0 版本之路上的一项关键举措是简化代码库，使其更易于维护且更易于第三方用户使用。我们已经从组织中删除了大部分代码深度，以使其更易于浏览，并且将我们自己的使用模式表明不需要位于单独功能区域中的更多代码放在一起。</p><p>我们还发现，很少有用户需要底层<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://github.com/microsoft/datashaper" target="_blank" rel="noreferrer noopener">DataShaper <span class="sr-only">（在新选项卡中打开）</span></a>引擎提供的声明性配置，因此我们将这 88 个详细工作流定义折叠为较小的一组 11 个工作流，这些工作流以功能性方式而不是组合方式运行。这使得管道更容易理解，并且是朝着更适合我们未来研究计划并全面提高性能的架构迈出的一步。通过折叠工作流程，我们现在可以减少未使用的输出工件、减少数据重复以及减少磁盘 I/O 操作。这种简化还减少了管道的内存占用，使用户能够使用 GraphRAG 索引和分析更大的数据集。</p><h3 class="wp-block-heading" id="incremental-ingest">增量摄取</h3><p>到目前为止，每次获取新信息时，不断发展的数据集都需要完全重新索引，以便重新生成知识模型。在 GraphRAG 1.0 中，我们在 CLI 中包含了一个新的<strong>更新</strong>命令，该命令计算现有索引和新添加的内容之间的增量，并智能地合并更新以最大程度地减少重新索引。 GraphRAG 使用 LLM 缓存机制在重新索引时尽可能节省成本，因此数据集的重新运行通常比初始运行更快、更便宜。添加全新内容可能会改变社区结构，从而需要重新计算大部分索引 - <a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://microsoft.github.io/graphrag/cli/#update" target="_blank" rel="noreferrer noopener">更新命令<span class="sr-only">（在新选项卡中打开）</span></a>解决了这个问题，同时还提高了答案质量。</p><h2 class="wp-block-heading" id="availability">可用性</h2><p>GraphRAG 版本 1.0 现已在<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://github.com/microsoft/graphrag" target="_blank" rel="noreferrer noopener">GitHub <span class="sr-only">（在新选项卡中打开）</span></a>上提供，并发布到<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://pypi.org/project/graphrag/">PyPI <span class="sr-only">（在新选项卡中打开）</span></a> 。立即查看<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://microsoft.github.io/graphrag/get_started/" target="_blank" rel="noreferrer noopener">入门<span class="sr-only">（在新选项卡中打开）</span></a>指南以使用 GraphRAG 1.0。今天。</p><h3 class="wp-block-heading" id="migrating">迁移</h3><p>我们建议用户迁移到 GraphRAG 1.0，它为用户和开发人员提供了简化的体验，包括多项改进。然而，由于其更新范围广泛，1.0 版不向后兼容。如果您在 1.0 版本之前使用过 GraphRAG 并且已有索引，则需要解决一些重大更改，但这应该是一个简单的过程。为了支持社区进行此迁移，我们在存储库中创建了<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://github.com/microsoft/graphrag/blob/main/v1-breaking-changes.md" target="_blank" rel="noreferrer noopener">迁移指南<span class="sr-only">（在新选项卡中打开），</span></a>其中包含更多信息。</p><h3 class="wp-block-heading" id="future-directions">未来方向</h3><p>我们最近发布了一种名为<a href="https://www.microsoft.com/en-us/research/blog/lazygraphrag-setting-a-new-standard-for-quality-and-cost/" target="_blank" rel="noreferrer noopener">LazyGraphRAG</a>的全新 GraphRAG 方法，该方法执行最少的预先索引以避免在执行用户查询之前使用 LLM。这避免了基于 LLM 的对用户可能不感兴趣的大量内容的总结，因此即使在昂贵的处理之后也从未探索过。这种方法以 GraphRAG 成本的一小部分展示了强大的性能，并将在不久的将来作为用户的新选项添加​​到 GraphRAG 核心代码库中。</p><p>此外，Microsoft 一直在积极探索 GraphRAG 如何提高科学进步的速度，并且正在构建相关的 GraphRAG 功能，以与我们在<a class="msr-external-link glyph-append glyph-append-open-in-new-tab glyph-append-xsmall" href="https://blogs.microsoft.com/blog/2024/06/18/empowering-every-scientist-with-ai-augmented-scientific-discovery/" target="_blank" rel="noreferrer noopener">人工智能支持的科学发现方面的更广泛工作保持一致<span class="sr-only">（在新选项卡中打开）</span></a> 。</p><p>我们将继续完善代码库并研究架构更改，使用户能够使用自己的语言模型 API、存储提供程序和向量存储。我们对这一重大里程碑感到兴奋，这次重构为我们在 GraphRAG 领域的持续研究奠定了基础。</p><span id="label-external-link" class="sr-only" aria-hidden="true">在新选项卡中打开</span><p><a href="https://www.microsoft.com/en-us/research/blog/moving-to-graphrag-1-0-streamlining-ergonomics-for-developers-and-users/">《转向 GraphRAG 1.0 – 为开发人员和用户简化人体工程学》</a>一文首先出现在<a href="https://www.microsoft.com/en-us/research">Microsoft Research</a>上。</p> ]]>;</content:encoded></item></channel></rss>